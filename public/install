#!/usr/bin/env bash
# TofuPilot Self-Hosting Deployment Script
# Self-hosting deployment with automated configuration
set -e  # Exit on any error

#----------------------------#
#       Configuration        #
#----------------------------#
# Handle remote execution via curl pipe (process file descriptors /dev/fd/XX or /proc/self/fd/XX)
BASH_SOURCE_PATH="${BASH_SOURCE[0]}"
if [[ "$BASH_SOURCE_PATH" =~ ^/dev/fd/ ]] || [[ "$BASH_SOURCE_PATH" =~ ^/proc/self/fd/ ]] || [[ ! -f "$BASH_SOURCE_PATH" ]]; then
    # Remote execution detected - using current working directory
    SCRIPT_DIR="$(pwd)"
    echo "→ Running from remote installer"
else
    SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
fi

COMPOSE_FILE="$SCRIPT_DIR/docker-compose.yml"
ENV_FILE="$SCRIPT_DIR/.env"

# Options
CUSTOM_ENV_FILE=""
INSTALLER_URL="https://tofupilot.sh/install"

# Terminal color definitions
RED='\033[0;31m'; GREEN='\033[1;32m'; NC='\033[0m'
# Brand colors
BRAND_BLUE='\033[38;2;59;130;246m'    # Blue-500
BRAND_GOLD='\033[38;2;234;179;8m'     # Yellow-500

# Corporate branding display
show_banner() {
    echo
    echo -e " ${BRAND_BLUE}╭${NC} ${BRAND_GOLD}✈${NC} ${BRAND_BLUE}╮${NC}"
    echo -e " ${NC}[•ᴗ•] TofuPilot Self-Hosting Installer${NC}"
    echo
}

#----------------------------#
#         Functions          #
#----------------------------#
log(){ echo -e "${GREEN}✓ $1${NC}"; }
warn(){ echo -e "${BRAND_GOLD}! $1${NC}"; }
error(){ echo -e "${RED}✗ $1${NC}"; exit 1; }
info(){ echo -e "${BRAND_BLUE}→ $1${NC}"; }
step(){ 
    echo
    echo -e "${BRAND_GOLD}Step $1${NC}"
    echo -e "${BRAND_GOLD}─────────────────────────────────────────────${NC}"
    echo
}

command_exists(){ command -v "$1" >/dev/null 2>&1; }
generate_password(){ openssl rand -base64 32 | tr -d "=+/" | cut -c1-25; }

# Configuration Schema - Single source of truth for field definitions
# Using bash-compatible approach instead of associative arrays

# Get field configuration by name
get_field_config() {
    local field="$1"
    case "$field" in
        # Domain Configuration
        "DOMAIN_NAME")
            echo "required|Domain name for TofuPilot||# Domain Configuration"
            ;;
        "STORAGE_DOMAIN_NAME")
            echo "required|Storage subdomain||"
            ;;
        # SSL Configuration  
        "SSL_MODE")
            echo "optional|SSL certificate mode|letsencrypt|# SSL Configuration
# Case 1: Let's Encrypt (automatic SSL certificates)"
            ;;
        "SSL_LETSENCRYPT_EMAIL")
            echo "conditional_ssl_letsencrypt|Email for Let's Encrypt certificates|your-email@example.com|"
            ;;
        "SSL_CERT_PATH")
            echo "conditional_ssl_custom|Path to SSL certificate file||# Case 2: Custom SSL certificates (uncomment and set paths)
# SSL_MODE=custom"
            ;;
        "SSL_KEY_PATH")
            echo "conditional_ssl_custom|Path to SSL private key file||"
            ;;
        # Authentication Configuration
        "AUTH_GOOGLE_ID")
            echo "optional|Google OAuth Client ID||# Authentication Configuration
# Configure at least one authentication method (remove lines for methods you don't want)

# Google OAuth (remove these lines if you don't want Google authentication)"
            ;;
        "AUTH_GOOGLE_SECRET")
            echo "optional|Google OAuth Client Secret||"
            ;;
        "AUTH_MICROSOFT_ENTRA_ID_ID")
            echo "optional|Microsoft Entra ID Client ID||# Microsoft Entra ID (remove these lines if you don't want Microsoft authentication)"
            ;;
        "AUTH_MICROSOFT_ENTRA_ID_SECRET")
            echo "optional|Microsoft Entra ID Client Secret||"
            ;;
        "AUTH_MICROSOFT_ENTRA_ID_ISSUER")
            echo "optional|Microsoft Entra ID Issuer URL||"
            ;;
        # Email Configuration
        "EMAIL_SMTP_HOST")
            echo "optional|SMTP server hostname||

# Email Configuration"
            ;;
        "EMAIL_SMTP_PORT")
            echo "optional|SMTP port|587|"
            ;;
        "EMAIL_SMTP_USER")
            echo "optional|SMTP username||"
            ;;
        "EMAIL_SMTP_PASSWORD")
            echo "optional|SMTP password||"
            ;;
        "EMAIL_FROM_AUTH")
            echo "optional|From email address||"
            ;;
        # Development Mode
        "GITHUB_TOKEN")
            echo "auth_method_development|GitHub Personal Access Token||# Development Mode (optional)"
            ;;
        *)
            echo "unknown||||"
            ;;
    esac
}

# Helper functions for configuration schema
get_field_requirement() {
    local field="$1"
    get_field_config "$field" | cut -d'|' -f1
}

get_field_description() {
    local field="$1"
    get_field_config "$field" | cut -d'|' -f2
}

get_field_default() {
    local field="$1"
    get_field_config "$field" | cut -d'|' -f3
}

get_field_comment() {
    local field="$1"
    get_field_config "$field" | cut -d'|' -f4
}

# Get all schema field names
get_all_schema_fields() {
    echo "DOMAIN_NAME STORAGE_DOMAIN_NAME SSL_MODE SSL_LETSENCRYPT_EMAIL SSL_CERT_PATH SSL_KEY_PATH AUTH_GOOGLE_ID AUTH_GOOGLE_SECRET AUTH_MICROSOFT_ENTRA_ID_ID AUTH_MICROSOFT_ENTRA_ID_SECRET AUTH_MICROSOFT_ENTRA_ID_ISSUER EMAIL_SMTP_HOST EMAIL_SMTP_PORT EMAIL_SMTP_USER EMAIL_SMTP_PASSWORD EMAIL_FROM_AUTH GITHUB_TOKEN"
}

# Check if field is required based on current context
is_field_required() {
    local field="$1"
    local requirement=$(get_field_requirement "$field")
    
    case "$requirement" in
        "required")
            return 0
            ;;
        "conditional_ssl_letsencrypt")
            [ "${SSL_MODE:-letsencrypt}" = "letsencrypt" ] && return 0
            return 1
            ;;
        "conditional_ssl_custom")
            [ "$SSL_MODE" = "custom" ] && return 0
            return 1
            ;;
        "auth_method_production")
            [ "$DEV_MODE" != "true" ] && return 0
            return 1
            ;;
        "auth_method_development")
            [ "$DEV_MODE" = "true" ] && return 0
            return 1
            ;;
        *)
            return 1
            ;;
    esac
}

# Generate empty .env template
generate_env_template() {
    local template_file="my-tofupilot-config.env"
    
    # Start template
    cat > "$template_file" <<EOF
# TofuPilot Self-Hosting Configuration
# Fill in your values and use with --env-file

EOF

    # Generate template maintaining the exact same format as before
    cat >> "$template_file" <<'EOF'
# Domain Configuration
DOMAIN_NAME=
STORAGE_DOMAIN_NAME=

# SSL Configuration
# Case 1: Let's Encrypt (automatic SSL certificates)
SSL_MODE=letsencrypt
SSL_LETSENCRYPT_EMAIL=your-email@example.com

# Case 2: Custom SSL certificates (uncomment and set paths)
# SSL_MODE=custom
# SSL_CERT_PATH=/path/to/your/certificate.crt
# SSL_KEY_PATH=/path/to/your/private.key

# Authentication Configuration
# Configure at least one authentication method (remove lines for methods you don't want)

# Google OAuth (remove these lines if you don't want Google authentication)
AUTH_GOOGLE_ID=
AUTH_GOOGLE_SECRET=

# Microsoft Entra ID (remove these lines if you don't want Microsoft authentication)
AUTH_MICROSOFT_ENTRA_ID_ID=
AUTH_MICROSOFT_ENTRA_ID_SECRET=
AUTH_MICROSOFT_ENTRA_ID_ISSUER=

# Email Configuration
EMAIL_SMTP_HOST=
EMAIL_SMTP_PORT=587
EMAIL_SMTP_USER=
EMAIL_SMTP_PASSWORD=
EMAIL_FROM_AUTH=

# Development Mode (optional)
# GITHUB_TOKEN=
EOF

    log "Generated configuration template: $template_file"
    echo
    info "Next steps:"
    echo "  1. Edit it: nano $template_file"
    echo "  2. Run script: curl -sSL ${INSTALLER_URL} | bash -s -- --env-file $template_file"
}

# Environment variable retrieval utility
get_env_value() {
    local var_name="$1"
    if [ -f "$ENV_FILE" ]; then
        grep -E "^${var_name}=" "$ENV_FILE" 2>/dev/null | cut -d= -f2- | tr -d '"'
    fi
}

# Interactive configuration prompt with default value handling
prompt_env() {
    local var_name="$1"
    local message="$2"
    local secret="${3:-false}"
    local existing_value=""
    local user_input=""
    
    # Get existing value from .env file
    if [ -f "$ENV_FILE" ]; then
        existing_value=$(grep -E "^${var_name}=" "$ENV_FILE" 2>/dev/null | cut -d= -f2- | tr -d '"' || true)
    fi
    
    # Display the prompt with existing value as default
    if [ -n "$existing_value" ] && [ "$secret" = "false" ]; then
        printf "%s [%s]: " "$message" "$existing_value" >&2
    elif [ -n "$existing_value" ] && [ "$secret" = "true" ]; then
        printf "%s [***hidden***]: " "$message" >&2
    else
        printf "%s: " "$message" >&2
    fi
    
    if [ "$secret" = "true" ]; then
        read -s user_input </dev/tty
        echo >&2
    else
        read user_input </dev/tty
    fi
    
    # Use existing value if user pressed enter
    if [ -z "$user_input" ] && [ -n "$existing_value" ]; then
        user_input="$existing_value"
    fi
    
    echo "$user_input"
}

# Interactive prompt with customizable default value
prompt_env_with_default() {
    local var_name="$1"
    local message="$2"
    local default_value="$3"
    local secret="${4:-false}"
    local user_input=""
    
    # Display the prompt with default value
    if [ "$secret" = "false" ]; then
        printf "%s [%s]: " "$message" "$default_value" >&2
    else
        printf "%s [***hidden***]: " "$message" >&2
    fi
    
    if [ "$secret" = "true" ]; then
        read -s user_input </dev/tty
        echo >&2
    else
        read user_input </dev/tty
    fi
    
    # Use default value if user pressed enter
    if [ -z "$user_input" ]; then
        user_input="$default_value"
    fi
    
    echo "$user_input"
}

# Check all required variables with detailed validation feedback
check_all_required_vars() {
    local all_valid=true
    local validation_errors=()

    # Check schema-defined required fields
    for field in $(get_all_schema_fields); do
        if is_field_required "$field"; then
            local value=$(get_env_value "$field")
            local description=$(get_field_description "$field")
            
            if [ -z "$value" ]; then
                all_valid=false
                case "$(get_field_requirement "$field")" in
                    "conditional_ssl_letsencrypt")
                        validation_errors+=("Missing required variable: $field (required for Let's Encrypt SSL)")
                        ;;
                    "conditional_ssl_custom")
                        validation_errors+=("Missing required variable: $field (required for custom SSL mode)")
                        ;;
                    *)
                        validation_errors+=("Missing required variable: $field")
                        ;;
                esac
            fi
        fi
    done

    # Check authentication methods - at least one must be configured (preserve existing logic)
    local google_id=$(get_env_value "AUTH_GOOGLE_ID")
    local microsoft_id=$(get_env_value "AUTH_MICROSOFT_ENTRA_ID_ID")
    local smtp_host=$(get_env_value "EMAIL_SMTP_HOST")
    local github_token=$(get_env_value "GITHUB_TOKEN")
    
    # Auth method validation depends on dev mode
    if [ "$DEV_MODE" = "true" ]; then
        if [ -z "$github_token" ]; then
            all_valid=false
            validation_errors+=("Development mode requires GITHUB_TOKEN")
        fi
    else
        if [ -z "$google_id" ] && [ -z "$microsoft_id" ] && [ -z "$smtp_host" ]; then
            all_valid=false
            validation_errors+=("At least one authentication method must be configured:")
            validation_errors+=("  • Google OAuth (AUTH_GOOGLE_ID + AUTH_GOOGLE_SECRET)")
            validation_errors+=("  • Microsoft Entra ID (AUTH_MICROSOFT_ENTRA_ID_ID + AUTH_MICROSOFT_ENTRA_ID_SECRET + AUTH_MICROSOFT_ENTRA_ID_ISSUER)")
            validation_errors+=("  • SMTP Email (EMAIL_SMTP_HOST + EMAIL_SMTP_USER + EMAIL_SMTP_PASSWORD + EMAIL_FROM_AUTH)")
        fi
    fi
    
    # Check SSL certificate files exist if custom mode is specified
    local ssl_mode=$(get_env_value "SSL_MODE")
    if [ "$ssl_mode" = "custom" ]; then
        local ssl_cert_path=$(get_env_value "SSL_CERT_PATH")
        local ssl_key_path=$(get_env_value "SSL_KEY_PATH")
        if [ -n "$ssl_cert_path" ] && [ -n "$ssl_key_path" ]; then
            if [ ! -f "$ssl_cert_path" ] || [ ! -f "$ssl_key_path" ]; then
                all_valid=false
                validation_errors+=("SSL certificate files not found:")
                validation_errors+=("  SSL_CERT_PATH: $ssl_cert_path")
                validation_errors+=("  SSL_KEY_PATH: $ssl_key_path")
            fi
        fi
    fi

    # Print validation results if there are errors
    if [ "$all_valid" = "false" ]; then
        echo
        echo -e "${RED}✗ Environment validation failed:${NC}"
        for error in "${validation_errors[@]}"; do
            echo "  $error"
        done
        echo
        if [ "$DEV_MODE" = "true" ]; then
            echo "Current development mode status:"
            if [ -n "$github_token" ]; then
                echo "  ✓ GitHub Token: configured"
            else
                echo "  ✗ GitHub Token: not configured"
            fi
        else
            echo "Current authentication status:"
            if [ -n "$google_id" ]; then
                echo "  ✓ Google OAuth: configured"
            else
                echo "  ✗ Google OAuth: not configured"
            fi
            if [ -n "$microsoft_id" ]; then
                echo "  ✓ Microsoft Entra ID: configured"
            else
                echo "  ✗ Microsoft Entra ID: not configured"
            fi
            if [ -n "$smtp_host" ]; then
                echo "  ✓ SMTP Email: configured"
            else
                echo "  ✗ SMTP Email: not configured"
            fi
        fi
        return 1
    fi

    return 0
}


# Test SMTP connection
test_smtp_connection() {
    local host="$1"
    local port="$2"
    local user="$3"
    local password="$4"
    
    info "Testing SMTP connection to ${host}:${port}..."
    
    # Test basic connectivity
    if ! command_exists nc && ! command_exists telnet; then
        warn "Cannot test SMTP connection - nc/telnet not available"
        return 0
    fi
    
    # Test port connectivity
    if command_exists nc; then
        if echo "quit" | nc -w 3 "$host" "$port" >/dev/null 2>&1; then
            log "SMTP server connectivity"
        else
            warn "Cannot connect to SMTP server ${host}:${port}"
            return 1
        fi
    elif command_exists telnet; then
        if echo "quit" | timeout 3 telnet "$host" "$port" >/dev/null 2>&1; then
            log "SMTP server connectivity"
        else
            warn "Cannot connect to SMTP server ${host}:${port}"
            return 1
        fi
    fi
    
    # If we have authentication details, test with a simple SMTP command
    if [ -n "$user" ] && [ -n "$password" ] && command_exists openssl; then
        local smtp_test=""
        local auth_success=false
        
        # Try STARTTLS first (ports 587, 25)
        if [ "$port" = "587" ] || [ "$port" = "25" ]; then
            smtp_test=$(timeout 10 openssl s_client -connect "$host:$port" -starttls smtp -quiet 2>/dev/null <<EOF
EHLO localhost
AUTH LOGIN
$(echo -n "$user" | base64)
$(echo -n "$password" | base64)
QUIT
EOF
)
        # Try implicit SSL/TLS (port 465, 2525)
        elif [ "$port" = "465" ] || [ "$port" = "2525" ]; then
            smtp_test=$(timeout 10 openssl s_client -connect "$host:$port" -quiet 2>/dev/null <<EOF
EHLO localhost
AUTH LOGIN
$(echo -n "$user" | base64)
$(echo -n "$password" | base64)
QUIT
EOF
)
        else
            # Unknown port, try STARTTLS first, then SSL
            smtp_test=$(timeout 10 openssl s_client -connect "$host:$port" -starttls smtp -quiet 2>/dev/null <<EOF
EHLO localhost
AUTH LOGIN
$(echo -n "$user" | base64)
$(echo -n "$password" | base64)
QUIT
EOF
)
            if [ -z "$smtp_test" ] || echo "$smtp_test" | grep -q "connect:errno"; then
                smtp_test=$(timeout 10 openssl s_client -connect "$host:$port" -quiet 2>/dev/null <<EOF
EHLO localhost
AUTH LOGIN
$(echo -n "$user" | base64)
$(echo -n "$password" | base64)
QUIT
EOF
)
            fi
        fi
        
        # Check authentication result
        if echo "$smtp_test" | grep -qi "235\|Authentication successful\|login ok"; then
            log "SMTP authentication successful"
            return 0
        elif echo "$smtp_test" | grep -qi "530\|535\|Authentication failed\|invalid credentials\|login failed"; then
            warn "SMTP authentication failed - please verify credentials"
            return 1
        elif echo "$smtp_test" | grep -qi "connect:errno\|connection refused\|network unreachable"; then
            warn "Cannot establish SSL/TLS connection to SMTP server"
            return 1
        else
            # If we can't determine the auth result, just warn but don't fail
            warn "SMTP server accessible but authentication could not be verified"
            info "This may be due to server-specific authentication requirements"
            return 0
        fi
    fi
    
    return 0
}

# Container Image Access Verification (Production)
verify_image_access() {
    info "Verifying TofuPilot image access..."
    
    # Test pulling TofuPilot production image (should be publicly available)
    if docker pull --platform linux/amd64 ghcr.io/tofupilot/tofupilot:latest >/dev/null 2>&1; then
        log "TofuPilot production image access confirmed"
    else
        error "Cannot pull ghcr.io/tofupilot/tofupilot:latest. Please check your internet connection."
    fi
}

# GitHub Authentication and Registry Access Verification (Development)
github_auth() {
    # If GITHUB_TOKEN is already set (e.g. from --env-file), do non-interactive login:
    if [ -n "${GITHUB_TOKEN:-}" ]; then
        log "Using GITHUB_TOKEN from .env; skipping interactive GitHub prompt"

        # 1) Validate token against GitHub API and get username
        github_user=$(curl -s -H "Authorization: token ${GITHUB_TOKEN}" https://api.github.com/user | grep '"login"' | cut -d'"' -f4)
        if [ -n "$github_user" ]; then
            log "GitHub API access (user: ${github_user})"
        else
            error "The GITHUB_TOKEN in .env failed GitHub API authentication."
        fi

        # 2) Docker login to ghcr.io using the retrieved username
        if echo "${GITHUB_TOKEN}" | docker login ghcr.io -u "$github_user" --password-stdin >/dev/null 2>&1; then
            log "Docker registry login to ghcr.io (user: ${github_user})"
        else
            error "Docker login to ghcr.io failed using GITHUB_TOKEN."
        fi

        # 3) Test pulling TofuPilot development image
        if docker pull --platform linux/amd64 ghcr.io/tofupilot/tofupilot-dev:latest >/dev/null 2>&1; then
            log "TofuPilot development image access confirmed"
        else
            error "Cannot pull ghcr.io/tofupilot/tofupilot-dev:latest. Check your GHCR permissions."
        fi

        return
    fi

    # Otherwise, perform interactive prompt:
    info "GitHub authentication required"
    echo "A GitHub Personal Access Token with 'read:packages' permission is required"
    echo "Generate token at: https://github.com/settings/tokens"
    echo

    echo -n "GitHub Personal Access Token: "
    read -s github_token </dev/tty
    echo

    if [ -z "$github_token" ]; then
        error "Personal access token is required"
    fi

    echo
    info "Validating GitHub credentials and permissions..."

    # Test GitHub API and get username
    github_user=$(curl -s -H "Authorization: token $github_token" https://api.github.com/user | grep '"login"' | cut -d'"' -f4)
    if [ -n "$github_user" ]; then
        log "GitHub API access ($github_user)"
    else
        error "GitHub API authentication failed. Please verify your token has the correct permissions"
    fi

    # Test package access
    if curl -s -H "Authorization: token $github_token" "https://api.github.com/user/packages?package_type=container" >/dev/null; then
        log "Package registry access"
    else
        warn "Package access limited"
    fi

    # Clean Docker auth
    docker logout >/dev/null 2>&1 || true

    # Test Docker login using the retrieved username
    if echo "$github_token" | docker login ghcr.io -u "$github_user" --password-stdin >/dev/null 2>&1; then
        log "Docker registry login"
    else
        error "GitHub Container Registry authentication failed. Please verify your credentials"
    fi

    # Test image pull
    if docker pull --platform linux/amd64 ghcr.io/tofupilot/tofupilot-dev:latest >/dev/null 2>&1; then
        log "TofuPilot development image access"
    else
        error "Unable to access TofuPilot development container image. Please verify your repository access permissions"
    fi

    log "Authentication complete"
}



# System Prerequisites and Dependency Validation
check_requirements() {
    info "Performing system requirements validation"
    
    # OS check
    if ! command_exists apt; then
        error "This deployment requires Ubuntu or Debian Linux with APT package manager"
    fi
    log "Operating system"
    
    # Docker check
    if ! command_exists docker; then
        info "Installing Docker container runtime..."
        curl -fsSL https://get.docker.com | sh >/dev/null 2>&1
        sudo usermod -aG docker "$USER"
        log "Docker installed"
    else
        log "Docker found"
    fi
    
    # Docker permissions
    if ! docker ps >/dev/null 2>&1; then
        info "Configuring Docker runtime permissions..."
        if ! groups "$USER" | grep -q docker; then
            sudo usermod -aG docker "$USER"
        fi
        sudo chmod 666 /var/run/docker.sock 2>/dev/null || true
        
        if ! docker ps >/dev/null 2>&1; then
            error "Docker permission configuration failed. Please log out and log back in to apply group changes"
        fi
    fi
    log "Docker permissions"
    
    
    # Docker Compose
    if ! command_exists docker-compose && ! docker compose version >/dev/null 2>&1; then
        info "Installing Docker Compose orchestration tool..."
        sudo apt update >/dev/null 2>&1
        sudo apt install -y docker-compose-plugin >/dev/null 2>&1
        log "Docker Compose installed"
    else
        log "Docker Compose found"
    fi
    
    # Port check
    if command_exists netstat && sudo netstat -tlnp 2>/dev/null | grep -E ':80|:443' >/dev/null 2>&1; then
        warn "Ports 80/443 in use"
    elif command_exists ss && sudo ss -tlnp 2>/dev/null | grep -E ':80|:443' >/dev/null 2>&1; then
        warn "Ports 80/443 in use"
    else
        log "Ports available"
    fi
    
    # Architecture
    ARCH=$(uname -m)
    if [ "$ARCH" = "arm64" ] || [ "$ARCH" = "aarch64" ]; then
        warn "ARM64 detected - using emulation (may be slower)"
    else
        log "Architecture (AMD64)"
    fi
}
# Generate Docker Compose configuration for containerized deployment
# Generate Docker Compose configuration for containerized deployment
create_compose_file() {
  log "Creating Docker Compose configuration..."
  
  # Debug: Show key variables
  info "DOMAIN_NAME='$DOMAIN_NAME'"
  info "STORAGE_DOMAIN_NAME='$STORAGE_DOMAIN_NAME'"
  
  # Validate required variables
  if [ -z "$DOMAIN_NAME" ]; then
    error "DOMAIN_NAME is empty - cannot create Docker Compose configuration"
  fi
  if [ -z "$STORAGE_DOMAIN_NAME" ]; then
    error "STORAGE_DOMAIN_NAME is empty - cannot create Docker Compose configuration"
  fi
  
  # Remove existing compose file if it exists
  if [ -f "$COMPOSE_FILE" ]; then
    rm -f "$COMPOSE_FILE"
    info "Removed existing docker-compose.yml file"
  fi
  
  # Generate or reuse passwords for this deployment (must be exported for template)
  # Check if passwords already exist in .env file, generate only if missing
  export AUTH_SECRET=$(get_env_value "AUTH_SECRET")
  if [ -z "$AUTH_SECRET" ]; then
    export AUTH_SECRET=$(generate_password)
    info "Generated new AUTH_SECRET"
  else
    info "Using existing AUTH_SECRET"
  fi
  
  export GEL_PASSWORD=$(get_env_value "GEL_PASSWORD")
  if [ -z "$GEL_PASSWORD" ]; then
    export GEL_PASSWORD=$(generate_password)
    info "Generated new GEL_PASSWORD"
  else
    info "Using existing GEL_PASSWORD"
  fi
  
  export S3_SECRET_ACCESS_KEY=$(get_env_value "S3_SECRET_ACCESS_KEY")
  if [ -z "$S3_SECRET_ACCESS_KEY" ]; then
    export S3_SECRET_ACCESS_KEY=$(generate_password)
    info "Generated new S3_SECRET_ACCESS_KEY"
  else
    info "Using existing S3_SECRET_ACCESS_KEY"
  fi

  cat > "$COMPOSE_FILE" <<EOF

services:
  # Reverse proxy (Traefik)
  tofupilot-proxy:
    platform: linux/amd64
    image: traefik:v3.0
    container_name: tofupilot-proxy
    restart: unless-stopped
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock:ro
EOF

  if [ "${SSL_MODE:-letsencrypt}" = "custom" ]; then
    cat >> "$COMPOSE_FILE" <<EOF
      - ${SSL_CERT_PATH}:/certs/tls.crt:ro
      - ${SSL_KEY_PATH}:/certs/tls.key:ro
      - ./traefik-tls.yml:/etc/traefik/dynamic/tls.yml:ro
    command:
      - "--api.dashboard=false"
      - "--providers.docker=true"
      - "--providers.docker.exposedbydefault=false"
      - "--providers.file.directory=/etc/traefik/dynamic"
      - "--providers.file.watch=true"
      - "--entrypoints.web.address=:80"
      - "--entrypoints.websecure.address=:443"
      - "--entrypoints.web.http.redirections.entrypoint.to=websecure"
      - "--entrypoints.web.http.redirections.entrypoint.scheme=https"
EOF
  else
    cat >> "$COMPOSE_FILE" <<EOF
      - tofupilot-proxy-acme:/data
    command:
      - "--api.dashboard=false"
      - "--providers.docker=true"
      - "--providers.docker.exposedbydefault=false"
      - "--entrypoints.web.address=:80"
      - "--entrypoints.websecure.address=:443"
      - "--certificatesresolvers.letsencrypt.acme.tlschallenge=true"
      - "--certificatesresolvers.letsencrypt.acme.email=${SSL_LETSENCRYPT_EMAIL}"
      - "--certificatesresolvers.letsencrypt.acme.storage=/data/acme.json"
      - "--entrypoints.web.http.redirections.entrypoint.to=websecure"
      - "--entrypoints.web.http.redirections.entrypoint.scheme=https"
EOF
  fi

  cat >> "$COMPOSE_FILE" <<EOF
    ports:
      - "80:80"
      - "443:443"
    environment:
      - ACME_EMAIL=${SSL_LETSENCRYPT_EMAIL}
    networks:
      - tofupilot

  # TofuPilot Application
  tofupilot-app:
    platform: linux/amd64
EOF

  # Add the appropriate image based on mode
  if [ "$DEV_MODE" = "true" ]; then
    cat >> "$COMPOSE_FILE" <<EOF
    image: ghcr.io/tofupilot/tofupilot-dev:latest
EOF
  else
    cat >> "$COMPOSE_FILE" <<EOF
    image: ghcr.io/tofupilot/tofupilot:latest
EOF
  fi

  cat >> "$COMPOSE_FILE" <<EOF
    container_name: tofupilot-app
    restart: unless-stopped
    depends_on:
      - tofupilot-database
      - tofupilot-storage
    environment:
      # Domain Configuration
      - NEXT_PUBLIC_SELF_HOSTED_APP_URL=https://${DOMAIN_NAME}
      
      # Authentication Configuration
      - AUTH_SECRET=${AUTH_SECRET}
      - AUTH_URL=https://${DOMAIN_NAME}
      - AUTH_GOOGLE_ID=${AUTH_GOOGLE_ID:-}
      - AUTH_GOOGLE_SECRET=${AUTH_GOOGLE_SECRET:-}
      - AUTH_MICROSOFT_ENTRA_ID_ID=${AUTH_MICROSOFT_ENTRA_ID_ID:-}
      - AUTH_MICROSOFT_ENTRA_ID_SECRET=${AUTH_MICROSOFT_ENTRA_ID_SECRET:-}
      - AUTH_MICROSOFT_ENTRA_ID_ISSUER=${AUTH_MICROSOFT_ENTRA_ID_ISSUER:-}
      
      # Email Configuration
      - EMAIL_SMTP_HOST=${EMAIL_SMTP_HOST:-}
      - EMAIL_SMTP_PORT=${EMAIL_SMTP_PORT:-587}
      - EMAIL_SMTP_USER=${EMAIL_SMTP_USER:-}
      - EMAIL_SMTP_PASSWORD=${EMAIL_SMTP_PASSWORD:-}
      - EMAIL_FROM_AUTH=${EMAIL_FROM_AUTH:-}
      
      # Database Configuration (automatic)
      - GEL_USER=edgedb
      - GEL_PASSWORD=${GEL_PASSWORD}
      - GEL_DATABASE=main
      - GEL_HOST=tofupilot-database
      - GEL_PORT=5656
      - GEL_CLIENT_TLS_SECURITY=insecure
      
      # Storage Configuration (automatic)
      - S3_ACCESS_KEY_ID=tofupilot
      - S3_SECRET_ACCESS_KEY=${S3_SECRET_ACCESS_KEY}
      - S3_ENDPOINT_URL_EXTERNAL=https://${STORAGE_DOMAIN_NAME}
      - S3_ENDPOINT_URL_INTERNAL=http://tofupilot-storage:9000
      - S3_BUCKET_NAME=tofupilot
      
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.tofupilot-app.rule=Host(\`${DOMAIN_NAME}\`)"
      - "traefik.http.routers.tofupilot-app.entrypoints=websecure"
EOF

  if [ "${SSL_MODE:-letsencrypt}" = "custom" ]; then
    cat >> "$COMPOSE_FILE" <<EOF
      - "traefik.http.routers.tofupilot-app.tls=true"
      - "traefik.http.services.tofupilot-app.loadbalancer.server.port=3000"
    networks:
      - tofupilot
EOF
  else
    cat >> "$COMPOSE_FILE" <<EOF
      - "traefik.http.routers.tofupilot-app.tls.certresolver=letsencrypt"
      - "traefik.http.services.tofupilot-app.loadbalancer.server.port=3000"
    networks:
      - tofupilot
EOF
  fi

  cat >> "$COMPOSE_FILE" <<EOF

  # Database
  tofupilot-database:
    platform: linux/amd64
    image: geldata/gel:latest
    container_name: tofupilot-database
    restart: unless-stopped
    environment:
      - GEL_USER=edgedb
      - GEL_PASSWORD=${GEL_PASSWORD}
      - GEL_DATABASE=main
      - GEL_SERVER_TLS_CERT_MODE=generate_self_signed
      - GEL_SERVER_SECURITY=insecure_dev_mode
    volumes:
      - tofupilot-database-data:/var/lib/gel/data
    ports:
      - "127.0.0.1:5656:5656"
    networks:
      - tofupilot

  # Object Storage (MinIO)
  tofupilot-storage:
    platform: linux/amd64
    image: minio/minio:latest
    container_name: tofupilot-storage
    restart: unless-stopped
    command: server /data --console-address ":9001"
    environment:
      - MINIO_ROOT_USER=tofupilot
      - MINIO_ROOT_PASSWORD=${S3_SECRET_ACCESS_KEY}
      - MINIO_BUCKETS=tofupilot
    volumes:
      - tofupilot-storage-data:/data
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.tofupilot-storage.rule=Host(\`${STORAGE_DOMAIN_NAME}\`)"
      - "traefik.http.routers.tofupilot-storage.entrypoints=websecure"
EOF

  if [ "${SSL_MODE:-letsencrypt}" = "custom" ]; then
    cat >> "$COMPOSE_FILE" <<EOF
      - "traefik.http.routers.tofupilot-storage.tls=true"
      - "traefik.http.services.tofupilot-storage.loadbalancer.server.port=9000"
    networks:
      - tofupilot
EOF
  else
    cat >> "$COMPOSE_FILE" <<EOF
      - "traefik.http.routers.tofupilot-storage.tls.certresolver=letsencrypt"
      - "traefik.http.services.tofupilot-storage.loadbalancer.server.port=9000"
    networks:
      - tofupilot
EOF
  fi

  cat >> "$COMPOSE_FILE" <<'EOF'

networks:
  tofupilot:
    driver: bridge

volumes:
  tofupilot-database-data:
  tofupilot-storage-data:
EOF

  # Add ACME volume if using Let's Encrypt
  if [ "${SSL_MODE:-letsencrypt}" = "letsencrypt" ]; then
    cat >> "$COMPOSE_FILE" <<EOF
  tofupilot-proxy-acme:
EOF
  fi


  # Create TLS configuration file for custom certificates
  if [ "${SSL_MODE:-letsencrypt}" = "custom" ]; then
    create_traefik_tls_config
  fi

  log "Docker Compose file created"
}

# Create Traefik TLS configuration file for custom certificates
create_traefik_tls_config() {
  local tls_config_file="$SCRIPT_DIR/traefik-tls.yml"
  
  log "Creating Traefik TLS configuration..."
  
  cat > "$tls_config_file" <<EOF
# TLS Configuration for Custom Certificates
tls:
  certificates:
    - certFile: /certs/tls.crt
      keyFile: /certs/tls.key
      stores:
        - default
  stores:
    default:
      defaultCertificate:
        certFile: /certs/tls.crt
        keyFile: /certs/tls.key
EOF
  
  log "TLS configuration file created at $tls_config_file"
}

# Generate application environment configuration
# Generate application environment configuration
create_env_file() {
    info "Creating environment file..."
    
    if [ -f "$ENV_FILE" ]; then
        log "Updating existing .env file"
    else
        log "Creating new .env file"
    fi
    
    cat > "$ENV_FILE" <<EOF
# ==========================================
# TofuPilot Self-Hosting Configuration
# AUTO-GENERATED FILE - DO NOT DELETE
# ==========================================
# This file contains auto-generated passwords and secrets.
# Deleting this file will cause service authentication failures.
# The installer will reuse existing values when re-run.

# Domain Configuration
DOMAIN_NAME=${DOMAIN_NAME}
STORAGE_DOMAIN_NAME=${STORAGE_DOMAIN_NAME}
SSL_LETSENCRYPT_EMAIL=${SSL_LETSENCRYPT_EMAIL}

# SSL Configuration
SSL_MODE=${SSL_MODE:-letsencrypt}
SSL_CERT_PATH=${SSL_CERT_PATH:-}
SSL_KEY_PATH=${SSL_KEY_PATH:-}

# Authentication Configuration
AUTH_GOOGLE_ID=${AUTH_GOOGLE_ID:-}
AUTH_GOOGLE_SECRET=${AUTH_GOOGLE_SECRET:-}
AUTH_MICROSOFT_ENTRA_ID_ID=${AUTH_MICROSOFT_ENTRA_ID_ID:-}
AUTH_MICROSOFT_ENTRA_ID_SECRET=${AUTH_MICROSOFT_ENTRA_ID_SECRET:-}
AUTH_MICROSOFT_ENTRA_ID_ISSUER=${AUTH_MICROSOFT_ENTRA_ID_ISSUER:-}

# Email Configuration
EMAIL_SMTP_HOST=${EMAIL_SMTP_HOST:-}
EMAIL_SMTP_PORT=${EMAIL_SMTP_PORT:-587}
EMAIL_SMTP_USER=${EMAIL_SMTP_USER:-}
EMAIL_SMTP_PASSWORD=${EMAIL_SMTP_PASSWORD:-}
EMAIL_FROM_AUTH=${EMAIL_FROM_AUTH:-}

# Auto-generated secrets (DO NOT MODIFY - generated automatically by installer)
AUTH_SECRET=${AUTH_SECRET}
GEL_PASSWORD=${GEL_PASSWORD}
S3_SECRET_ACCESS_KEY=${S3_SECRET_ACCESS_KEY}
EOF

    log "Environment configuration written to ${ENV_FILE}"
}


# Save current configuration variables to .env file during interactive setup
# Partial config excludes auto-generated secrets since full .env is saved before docker commands
save_partial_config() {
    cat > "$ENV_FILE" <<EOF
# ==========================================
# TofuPilot Self-Hosting Configuration
# PARTIAL CONFIG - AUTO-GENERATED FILE
# ==========================================
# This file will be completed with auto-generated secrets during deployment.

# Domain Configuration
DOMAIN_NAME=${DOMAIN_NAME:-}
STORAGE_DOMAIN_NAME=${STORAGE_DOMAIN_NAME:-}

# SSL Configuration
SSL_MODE=${SSL_MODE:-letsencrypt}
SSL_LETSENCRYPT_EMAIL=${SSL_LETSENCRYPT_EMAIL:-}
SSL_CERT_PATH=${SSL_CERT_PATH:-}
SSL_KEY_PATH=${SSL_KEY_PATH:-}

# Authentication Configuration
AUTH_GOOGLE_ID=${AUTH_GOOGLE_ID:-}
AUTH_GOOGLE_SECRET=${AUTH_GOOGLE_SECRET:-}
AUTH_MICROSOFT_ENTRA_ID_ID=${AUTH_MICROSOFT_ENTRA_ID_ID:-}
AUTH_MICROSOFT_ENTRA_ID_SECRET=${AUTH_MICROSOFT_ENTRA_ID_SECRET:-}
AUTH_MICROSOFT_ENTRA_ID_ISSUER=${AUTH_MICROSOFT_ENTRA_ID_ISSUER:-}

# Email Configuration
EMAIL_SMTP_HOST=${EMAIL_SMTP_HOST:-}
EMAIL_SMTP_PORT=${EMAIL_SMTP_PORT:-587}
EMAIL_SMTP_USER=${EMAIL_SMTP_USER:-}
EMAIL_SMTP_PASSWORD=${EMAIL_SMTP_PASSWORD:-}
EMAIL_FROM_AUTH=${EMAIL_FROM_AUTH:-}
EOF
}

# Configuration loading (from file or interactive)
load_config() {
    # Flag to track if config came from complete file vs interactive
    CONFIG_FROM_FILE=false
    # Check if custom env file is specified or .env exists and load it
    if [ -n "$CUSTOM_ENV_FILE" ] || [ -f "$ENV_FILE" ]; then
        if [ -n "$CUSTOM_ENV_FILE" ]; then
            info "Loading configuration from custom file: $ENV_FILE"
            # Custom env files are expected to be complete - load and return
            set -a
            source "$ENV_FILE"
            set +a
            CONFIG_FROM_FILE=true
            return
        else
            info "Loading existing configuration from: $ENV_FILE"
            set -a
            source "$ENV_FILE"
            set +a
            
            # For automatically created .env files, always continue with interactive setup
            # This allows users to resume/modify their configuration
            info "Resuming configuration with existing values as defaults..."
            # Continue to interactive prompts below
        fi
    fi
    
    # No .env file exists or partial config found, collect configuration interactively
    if [ ! -f "$ENV_FILE" ]; then
        info "No configuration file found, collecting configuration interactively"
    fi
    
    # Domain Configuration
    echo "Domain Configuration:"
    DOMAIN_NAME=$(prompt_env "DOMAIN_NAME" "Domain name" false)
    if [ -z "$DOMAIN_NAME" ]; then DOMAIN_NAME="tofupilot.example.com"; fi
    
    # Auto-generate storage domain based on main domain
    local storage_default="storage.${DOMAIN_NAME}"
    local existing_storage=$(get_env_value "STORAGE_DOMAIN_NAME")
    if [ -n "$existing_storage" ]; then
        storage_default="$existing_storage"
    fi
    STORAGE_DOMAIN_NAME=$(prompt_env_with_default "STORAGE_DOMAIN_NAME" "Storage domain" "$storage_default" false)
    
    # Save domain configuration
    save_partial_config
    
    echo
    echo "SSL Configuration:"
    info "Choose SSL certificate mode:"
    echo "  • letsencrypt: Automatic SSL certificates (recommended)"
    echo "  • custom: Use your own SSL certificate files"
    SSL_MODE=$(prompt_env_with_default "SSL_MODE" "SSL mode (letsencrypt/custom)" "letsencrypt" false)
    
    if [ "$SSL_MODE" = "custom" ]; then
        echo
        info "Custom SSL certificate configuration:"
        SSL_CERT_PATH=$(prompt_env "SSL_CERT_PATH" "Path to SSL certificate file (.crt/.pem)" false)
        SSL_KEY_PATH=$(prompt_env "SSL_KEY_PATH" "Path to SSL private key file (.key)" false)
        
        if [ -z "$SSL_CERT_PATH" ] || [ -z "$SSL_KEY_PATH" ]; then
            error "Both SSL_CERT_PATH and SSL_KEY_PATH must be specified when using custom SSL mode"
        fi
        
        # Validate certificate files exist
        if [ ! -f "$SSL_CERT_PATH" ]; then
            error "SSL certificate file not found: $SSL_CERT_PATH"
        fi
        if [ ! -f "$SSL_KEY_PATH" ]; then
            error "SSL private key file not found: $SSL_KEY_PATH"
        fi
        
        log "Custom SSL certificate files validated"
    elif [ "$SSL_MODE" != "letsencrypt" ]; then
        warn "Invalid SSL mode '$SSL_MODE', defaulting to letsencrypt"
        SSL_MODE="letsencrypt"
    fi
    
    if [ "$SSL_MODE" = "letsencrypt" ]; then
        echo
        info "Let's Encrypt SSL configuration:"
        # Auto-generate SSL email based on main domain  
        local email_default="admin@${DOMAIN_NAME}"
        local existing_email=$(get_env_value "SSL_LETSENCRYPT_EMAIL")
        if [ -n "$existing_email" ]; then
            email_default="$existing_email"
        fi
        SSL_LETSENCRYPT_EMAIL=$(prompt_env_with_default "SSL_LETSENCRYPT_EMAIL" "Let's Encrypt email" "$email_default" false)
        log "Let's Encrypt automatic SSL enabled"
    fi
    
    # Save SSL configuration
    save_partial_config

    echo
    echo "Security Configuration:"
    info "System will auto-generate secure passwords during deployment"

    echo
    echo "Authentication Configuration (required - choose at least one):"
    info "TofuPilot requires at least one authentication method"
    
    # Google OAuth Configuration
    local configure_google="y"
    local existing_google_id=$(get_env_value "AUTH_GOOGLE_ID")
    if [ -n "$existing_google_id" ]; then
        printf "Configure Google OAuth? (existing: ${existing_google_id}) [Y/n]: " >&2
        read configure_google </dev/tty
        echo >&2
        if [ "$configure_google" = "n" ] || [ "$configure_google" = "N" ]; then
            configure_google="n"
        fi
    else
        printf "Configure Google OAuth? [y/N]: " >&2
        read configure_google </dev/tty
        echo >&2
        if [ "$configure_google" != "y" ] && [ "$configure_google" != "Y" ]; then
            configure_google="n"
        fi
    fi
    
    if [ "$configure_google" != "n" ]; then
        AUTH_GOOGLE_ID=$(prompt_env "AUTH_GOOGLE_ID" "Google OAuth Client ID" false)
        if [ -n "$AUTH_GOOGLE_ID" ]; then
            AUTH_GOOGLE_SECRET=$(prompt_env "AUTH_GOOGLE_SECRET" "Google OAuth Client Secret" true)
        else
            AUTH_GOOGLE_SECRET=""
        fi
    else
        AUTH_GOOGLE_ID=""
        AUTH_GOOGLE_SECRET=""
    fi
    
    # Microsoft Entra ID Configuration
    local configure_microsoft="y"
    local existing_microsoft_id=$(get_env_value "AUTH_MICROSOFT_ENTRA_ID_ID")
    if [ -n "$existing_microsoft_id" ]; then
        printf "Configure Microsoft Entra ID? (existing: ${existing_microsoft_id}) [Y/n]: " >&2
        read configure_microsoft </dev/tty
        echo >&2
        if [ "$configure_microsoft" = "n" ] || [ "$configure_microsoft" = "N" ]; then
            configure_microsoft="n"
        fi
    else
        printf "Configure Microsoft Entra ID? [y/N]: " >&2
        read configure_microsoft </dev/tty
        echo >&2
        if [ "$configure_microsoft" != "y" ] && [ "$configure_microsoft" != "Y" ]; then
            configure_microsoft="n"
        fi
    fi
    
    if [ "$configure_microsoft" != "n" ]; then
        AUTH_MICROSOFT_ENTRA_ID_ID=$(prompt_env "AUTH_MICROSOFT_ENTRA_ID_ID" "Microsoft Entra ID Client ID" false)
        if [ -n "$AUTH_MICROSOFT_ENTRA_ID_ID" ]; then
            AUTH_MICROSOFT_ENTRA_ID_SECRET=$(prompt_env "AUTH_MICROSOFT_ENTRA_ID_SECRET" "Microsoft Entra ID Client Secret" true)
            AUTH_MICROSOFT_ENTRA_ID_ISSUER=$(prompt_env "AUTH_MICROSOFT_ENTRA_ID_ISSUER" "Microsoft Entra ID Issuer URL" false)
        else
            AUTH_MICROSOFT_ENTRA_ID_SECRET=""
            AUTH_MICROSOFT_ENTRA_ID_ISSUER=""
        fi
    else
        AUTH_MICROSOFT_ENTRA_ID_ID=""
        AUTH_MICROSOFT_ENTRA_ID_SECRET=""
        AUTH_MICROSOFT_ENTRA_ID_ISSUER=""
    fi
    
    # Save authentication configuration
    save_partial_config
    
    echo
    echo "Email Configuration:"
    
    # Check if SMTP is required (no OAuth methods configured)
    local smtp_required=false
    if [ -z "$AUTH_GOOGLE_ID" ] && [ -z "$AUTH_MICROSOFT_ENTRA_ID_ID" ]; then
        smtp_required=true
        info "SMTP email is REQUIRED since no OAuth methods are configured"
    else
        info "SMTP email is optional (OAuth is configured)"
    fi
    
    # Smart default for email from address
    local email_default="tofupilot@${DOMAIN_NAME}"
    local existing_email_from=$(get_env_value "EMAIL_FROM_AUTH")
    if [ -z "$existing_email_from" ]; then
        existing_email_from=$(get_env_value "EMAIL_FROM")
    fi
    if [ -n "$existing_email_from" ]; then
        email_default="$existing_email_from"
    fi
    
    # SMTP Configuration
    local configure_smtp="y"
    local existing_smtp_host=$(get_env_value "EMAIL_SMTP_HOST")
    if [ -z "$existing_smtp_host" ]; then
        existing_smtp_host=$(get_env_value "SMTP_HOST")
    fi
    
    if [ "$smtp_required" = "true" ]; then
        configure_smtp="y"
    elif [ -n "$existing_smtp_host" ]; then
        printf "Configure SMTP email? (existing: ${existing_smtp_host}) [Y/n]: " >&2
        read configure_smtp </dev/tty
        echo >&2
        if [ "$configure_smtp" = "n" ] || [ "$configure_smtp" = "N" ]; then
            configure_smtp="n"
        fi
    else
        printf "Configure SMTP email? [y/N]: " >&2
        read configure_smtp </dev/tty
        echo >&2
        if [ "$configure_smtp" != "y" ] && [ "$configure_smtp" != "Y" ]; then
            configure_smtp="n"
        fi
    fi
    
    if [ "$configure_smtp" != "n" ]; then
        EMAIL_SMTP_HOST=$(prompt_env "EMAIL_SMTP_HOST" "SMTP server hostname" false)
        if [ -z "$EMAIL_SMTP_HOST" ] && [ "$smtp_required" = "true" ]; then
            error "SMTP server hostname is required when no OAuth methods are configured"
        fi
        
        if [ -n "$EMAIL_SMTP_HOST" ]; then
            EMAIL_SMTP_PORT=$(prompt_env "EMAIL_SMTP_PORT" "SMTP port" false)
            if [ -z "$EMAIL_SMTP_PORT" ]; then
                EMAIL_SMTP_PORT=$(get_env_value "SMTP_PORT")
            fi
            if [ -z "$EMAIL_SMTP_PORT" ]; then
                EMAIL_SMTP_PORT="587"
            fi
            
            EMAIL_SMTP_USER=$(prompt_env "EMAIL_SMTP_USER" "SMTP username" false)
            if [ -z "$EMAIL_SMTP_USER" ]; then
                EMAIL_SMTP_USER=$(get_env_value "SMTP_USER")
            fi
            
            EMAIL_SMTP_PASSWORD=$(prompt_env "EMAIL_SMTP_PASSWORD" "SMTP password" true)
            if [ -z "$EMAIL_SMTP_PASSWORD" ]; then
                EMAIL_SMTP_PASSWORD=$(get_env_value "SMTP_PASSWORD")
            fi
            
            EMAIL_FROM_AUTH=$(prompt_env_with_default "EMAIL_FROM_AUTH" "From email address" "$email_default" false)
            
            # Test SMTP connection right after configuration
            echo
            info "Testing SMTP connection with host: '$EMAIL_SMTP_HOST', port: '$EMAIL_SMTP_PORT'"
            if ! test_smtp_connection "$EMAIL_SMTP_HOST" "$EMAIL_SMTP_PORT" "$EMAIL_SMTP_USER" "$EMAIL_SMTP_PASSWORD"; then
                echo
                if [ "$smtp_required" = "true" ]; then
                    error "SMTP authentication is REQUIRED but failed. Cannot continue without working email configuration."
                else
                    warn "SMTP configuration failed validation"
                    echo "Please check your SMTP credentials and try again:"
                    echo "  • Verify your SMTP server hostname and port"
                    echo "  • Check your username and password"
                    echo "  • Ensure your account has SMTP sending permissions"
                    echo
                    echo "Restart the installer to try again with corrected settings."
                    exit 1
                fi
            fi
        else
            EMAIL_SMTP_PORT="587"
            EMAIL_SMTP_USER=""
            EMAIL_SMTP_PASSWORD=""
            EMAIL_FROM_AUTH=""
        fi
    else
        EMAIL_SMTP_HOST=""
        EMAIL_SMTP_PORT="587"
        EMAIL_SMTP_USER=""
        EMAIL_SMTP_PASSWORD=""
        EMAIL_FROM_AUTH=""
    fi
    
    # Save final email configuration
    save_partial_config
    
    echo
    log "Configuration complete"
}

# Validate configuration
validate_config() {
    if [ "$CONFIG_FROM_FILE" = "true" ]; then
        info "Validating file-based configuration"
        
        # Run schema-based validation for file configs
        if ! check_all_required_vars; then
            error "Configuration validation failed"
        fi
        
        log "Configuration validation passed"
    else
        info "Skipping validation (interactive configuration is complete by design)"
    fi
}


# Deploy the application
deploy() {
    log "Starting deployment process..."
    
    # Configuration variables are already loaded in main script
    # Create configuration files
    info "Generating deployment configuration files..."
    create_compose_file

    #
    # ──► ALWAYS regenerate/overwrite .env so that any missing variables
    #    (passwords, secrets, defaults, etc.) get filled in.
    #
    create_env_file

    info "Downloading container images from registry..."
    if [ -n "$CUSTOM_ENV_FILE" ]; then
        if docker compose -f "$COMPOSE_FILE" --env-file "$ENV_FILE" pull; then
            log "Images downloaded"
        else
            error "Container image download failed. Please verify network connectivity and registry access"
        fi
        
        info "Initializing containerized services..."
        docker compose -f "$COMPOSE_FILE" --env-file "$ENV_FILE" up -d
    else
        if docker compose -f "$COMPOSE_FILE" pull; then
            log "Images downloaded"
        else
            error "Container image download failed. Please verify network connectivity and registry access"
        fi
        
        info "Initializing containerized services..."
        docker compose -f "$COMPOSE_FILE" up -d
    fi
    
    if ! docker compose -f "$COMPOSE_FILE" ps 2>/dev/null | grep -q "Up"; then
        error "Service initialization failed. Review deployment logs using: docker compose logs"
    fi
    
    log "Services started"
    
    
    # Quick app check
    info "Checking application status..."
    if docker compose -f "$COMPOSE_FILE" ps app 2>/dev/null | grep -q "Up"; then
        log "Application is running"
    else
        warn "Application initialization in progress. Monitor with: docker compose logs app"
    fi
    
    # Check if services are running
    info "Verifying all services..."
    
    if docker compose -f "$COMPOSE_FILE" ps 2>/dev/null | grep -q "Up"; then
        log "All services running"
        
        if docker compose -f "$COMPOSE_FILE" logs app 2>/dev/null | grep -q "exec format error"; then
            error "TofuPilot app failed with 'exec format error' – architecture compatibility issue. Check Docker platform emulation settings."

        fi
        
    else
        error "Some services failed to start. Check logs with: docker compose logs"
    fi
}

# Show deployment information
show_info() {
    info "What was deployed:"
    if [ "$DEV_MODE" = "true" ]; then
        echo "  • TofuPilot app (dev)"
    else
        echo "  • TofuPilot app"
    fi
    echo "  • TofuPilot database (Gel)"
    echo "  • TofuPilot storage (MinIO)"
    echo "  • TofuPilot proxy (Traefik)"
    if [ "${SSL_MODE:-letsencrypt}" = "custom" ]; then
        echo "  • Custom SSL certificates"
    else
        echo "  • Let's Encrypt SSL certificates"
    fi
    echo
    info "Your TofuPilot instance will be accessible at: https://${DOMAIN_NAME}"
    echo
    
    warn "Database Migration Notice:"
    echo "If this is your first TofuPilot installation, the database needs to migrate to"
    echo "the latest schema version. This process may take up to 5 minutes."
    echo "Monitor migration progress: curl -sSL ${INSTALLER_URL} | bash -s -- --logs app"
    echo
    
    warn "Complete setup if not done already:"
    if [ -n "$AUTH_GOOGLE_ID" ]; then
        echo "  • Google OAuth: Configure redirect URI:"
        echo "    https://${DOMAIN_NAME}/api/auth/callback/google"
    fi
    if [ -n "$AUTH_MICROSOFT_ENTRA_ID_ID" ]; then
        echo "  • Microsoft Entra ID: Configure redirect URI:"
        echo "    https://${DOMAIN_NAME}/api/auth/callback/microsoft-entra-id"
    fi
    echo "  • Configure firewall: https://tofupilot.com/self-hosting/firewall"
    echo "  • Configure backups: https://tofupilot.com/self-hosting/backup"
    echo
    info "Management commands:"
    echo "  • Check status: curl -sSL ${INSTALLER_URL} | bash -s -- --status"
    echo "  • View logs:    docker compose logs -f"
    echo "  • Restart:      docker compose restart"
    echo "  • Stop:         docker compose down"
    echo "  • Start:        docker compose up -d"
    echo
}



# Show service status
show_status() {
    if [ ! -f "$COMPOSE_FILE" ]; then
        error "No deployment found."
    fi
    
    log "Checking TofuPilot service status..."
    echo
    echo "TofuPilot Service Status"
    echo "======================="
    echo
    
    # Show docker-compose status (TofuPilot containers only)
    info "Docker Container Status:"
    docker compose -f "$COMPOSE_FILE" ps 2>/dev/null | grep tofupilot
    
    info "Data Volumes:"
    local volumes=$(docker system df -v 2>/dev/null | grep -E "(root_tofupilot-database-data|root_tofupilot-storage-data|root_tofupilot-proxy-acme)" | awk '{print $1 " " $3}')
    if [ -n "$volumes" ]; then
        echo "$volumes" | while read name size; do
            echo "  $name: $size"
        done
    fi
    
    echo
    echo "Health Checks:"
    
    # Source environment for domain names
    if [ -f "$ENV_FILE" ]; then
        set -a
        source "$ENV_FILE"
        set +a
    fi
    
    # Check if main app is responding
    info "Testing main application..."
    if curl -f -s -I "https://${DOMAIN_NAME:-localhost}" >/dev/null 2>&1; then
        echo "✓ Main application: healthy (https://${DOMAIN_NAME:-localhost})"
    elif curl -f -s -I "http://${DOMAIN_NAME:-localhost}" >/dev/null 2>&1; then
        echo "~ Main application: accessible (SSL provisioning)"
    else
        echo "✗ Main application: not responding"
    fi
    
    # Check storage
    info "Testing storage service..."
    if curl -f -s -I "https://${STORAGE_DOMAIN_NAME:-storage.localhost}" >/dev/null 2>&1; then
        echo "✓ Storage: healthy (https://${STORAGE_DOMAIN_NAME:-storage.localhost})"
    elif curl -f -s -I "http://${STORAGE_DOMAIN_NAME:-storage.localhost}" >/dev/null 2>&1; then
        echo "~ Storage: accessible (SSL provisioning)"  
    else
        echo "✗ Storage: not responding"
    fi
    
    echo
    echo "URLs:"
    echo "  Main app: https://${DOMAIN_NAME:-localhost}"
    echo "  Storage:  https://${STORAGE_DOMAIN_NAME:-storage.localhost}"
}


# Uninstall TofuPilot completely
uninstall_tofupilot() {
    echo
    echo "=========================================="
    echo -e "${RED}WARNING: TofuPilot Complete Uninstall${NC}"
    echo "=========================================="
    echo
    warn "This will completely remove:"
    echo "- All TofuPilot containers"
    echo "- All TofuPilot volumes (database and storage data will be lost)"
    echo "- Configuration files (.env, docker-compose.yml)"
    echo "- Docker images and unused volumes"
    echo
    
    printf "${RED}Are you sure you want to completely uninstall TofuPilot? (y/N): ${NC}"
    read -r confirm </dev/tty
    if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
        echo "Uninstall cancelled."
        exit 0
    fi
    
    echo
    printf "${RED}This action is IRREVERSIBLE. Type 'DELETE' to confirm: ${NC}"
    read -r final_confirm </dev/tty
    if [ "$final_confirm" != "DELETE" ]; then
        echo "Uninstall cancelled."
        exit 0
    fi
    
    echo
    step "1/6: Stopping services"
    info "Gracefully shutting down all TofuPilot containers..."
    if [ -f "$COMPOSE_FILE" ]; then
        docker compose -f "$COMPOSE_FILE" down -v 2>/dev/null || docker-compose -f "$COMPOSE_FILE" down -v 2>/dev/null || true
        log "Services stopped"
    else
        warn "No docker-compose.yml found"
    fi
    
    step "2/6: Removing containers"
    info "Deleting all TofuPilot container instances..."
    docker ps -a --filter "name=tofupilot" --format "{{.Names}}" | xargs -r docker rm -f 2>/dev/null || true
    log "Containers removed"
    
    step "3/6: Removing volumes"
    info "Permanently deleting all data volumes (database and storage)..."
    docker volume ls --filter "name=tofupilot" --format "{{.Name}}" | xargs -r docker volume rm 2>/dev/null || true
    docker volume ls --filter "name=root" --format "{{.Name}}" | grep -E "(tofupilot-database-data|tofupilot-storage-data|tofupilot-proxy-acme)" | xargs -r docker volume rm 2>/dev/null || true
    log "Volumes removed"
    
    step "4/6: Removing configuration"
    info "Cleaning up environment and configuration files..."
    rm -f "$ENV_FILE" "$COMPOSE_FILE" 2>/dev/null || true
    log "Configuration files removed"
    
    step "5/6: Cleaning docker system"
    info "Removing orphaned containers and unused Docker resources..."
    docker system prune -f --volumes 2>/dev/null || true
    log "Docker system cleaned"
    
    step "6/6: Removing images"
    info "Deleting TofuPilot container images from local registry..."
    docker images --filter "reference=ghcr.io/tofupilot/*" --format "{{.Repository}}:{{.Tag}}" | xargs -r docker rmi 2>/dev/null || true
    log "Images removed"
    
    echo
    log "TofuPilot completely uninstalled!"
    echo
    echo "To reinstall TofuPilot, run:"
    echo "  curl -sSL ${INSTALLER_URL} | bash"
    echo
}

# Show usage
usage() {
    echo "Usage: curl -sSL ${INSTALLER_URL} | bash -s -- [OPTIONS]"
    echo
    echo "Main Commands:"
    echo "  (no options)              Install/update production version"
    echo "  --development             Install/update development version (requires GitHub access)"
    echo "  --env-file <path>         Use a custom .env file (must contain all required variables)"
    echo "  --generate-env            Generate empty .env template file"
    echo
    echo "Service Management:"
    echo "  --status                  Show service status and health"
    echo "  --uninstall               Completely remove TofuPilot (with confirmation)"
    echo "  --help                    Show this help message"
    echo
    echo "Examples:"
    echo "  curl -sSL ${INSTALLER_URL} | bash                              # Install/update production"
    echo "  curl -sSL ${INSTALLER_URL} | bash -s -- --development          # Install/update development"
    echo "  curl -sSL ${INSTALLER_URL} | bash -s -- --env-file custom.env  # Use existing env"
    echo "  curl -sSL ${INSTALLER_URL} | bash -s -- --generate-env         # Generate .env template"
    echo
    echo "  curl -sSL ${INSTALLER_URL} | bash -s -- --status               # Check deployment status"
    echo "  curl -sSL ${INSTALLER_URL} | bash -s -- --uninstall            # Completely remove TofuPilot"
    echo
    echo "For more information, visit: https://docs.tofupilot.com"
}

#----------------------------#
#         Main Script        #
#----------------------------#

# Initialize variables
DEV_MODE="false"

# Show banner for all operations
show_banner

# Parse command line arguments
while [ $# -gt 0 ]; do
    case "${1:-}" in
        --env-file)
            shift
            CUSTOM_ENV_FILE="$1"
            [ ! -f "$CUSTOM_ENV_FILE" ] && error "Specified env file not found: $CUSTOM_ENV_FILE"
            ENV_FILE="$CUSTOM_ENV_FILE"
            info "Using custom env file: $ENV_FILE"
            shift
            ;;
        --development)
            DEV_MODE="true"
            shift
            ;;
        --generate-env)
            generate_env_template
            exit 0
            ;;
        --status)
            show_status
            exit 0
            ;;
        --uninstall)
            uninstall_tofupilot
            exit 0
            ;;
        --help)
            usage
            exit 0
            ;;
        "")
            ;;
        *)
            error "Unknown option: $1. Use --help for usage information."
            ;;
    esac
done

# Main installation flow

step "1/6: System checks"
check_requirements

echo
step "2/6: Image access verification"
if [ "$DEV_MODE" = "true" ]; then
    info "Development mode enabled - using private repository"
    github_auth
else
    verify_image_access
fi

echo
step "3/6: Configuration"
load_config

echo
step "4/6: Validation"
validate_config

echo
step "5/6: Deployment"
deploy

step "6/6: Next steps"
show_info


echo
