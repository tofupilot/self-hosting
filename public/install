#!/usr/bin/env bash
# TofuPilot Self-Hosting Deployment Script
# Self-hosting deployment with automated configuration
set -e  # Exit on any error

#----------------------------#
#       Configuration        #
#----------------------------#
# Handle remote execution via curl pipe (process file descriptors /dev/fd/XX or /proc/self/fd/XX)
BASH_SOURCE_PATH="${BASH_SOURCE[0]}"
if [[ "$BASH_SOURCE_PATH" =~ ^/dev/fd/ ]] || [[ "$BASH_SOURCE_PATH" =~ ^/proc/self/fd/ ]] || [[ ! -f "$BASH_SOURCE_PATH" ]]; then
    # Remote execution detected - using current working directory
    SCRIPT_DIR="$(pwd)"
    echo "â†’ Running from remote installer"
else
    SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
fi

COMPOSE_FILE="$SCRIPT_DIR/docker-compose.yml"
ENV_FILE="$SCRIPT_DIR/.env"

# Terminal color definitions for enhanced output formatting
RED='\033[0;31m'; GREEN='\033[1;32m'; YELLOW='\033[1;33m'; BLUE='\033[1;34m'; CYAN='\033[1;36m'; NC='\033[0m'

# Corporate branding display
show_banner() {
    # Colors for the tofu art
    local yellow="\033[33m"  # Yellow for the plane
    local blue="\033[34m"    # Blue for the cap border
    local reset="\033[0m"    # Reset color
    
    echo
    echo -e "    ${blue}â•­${reset} ${yellow}âœˆ${reset} ${blue}â•®${reset}"
    echo " [â€¢á´—â€¢] TofuPilot Self-Hosting Installer"
    echo
}

#----------------------------#
#         Functions          #
#----------------------------#
log(){ echo -e "${GREEN}âœ“ $1${NC}"; }
warn(){ echo -e "${YELLOW}! $1${NC}"; }
error(){ echo -e "${RED}âœ— $1${NC}"; exit 1; }
info(){ echo -e "${CYAN}â†’ $1${NC}"; }
step(){ 
    echo
    echo -e "${CYAN}>>> STEP $1${NC}"
    echo -e "${CYAN}-----------------------------${NC}"
    echo
}

command_exists(){ command -v "$1" >/dev/null 2>&1; }
generate_password(){ openssl rand -base64 32 | tr -d "=+/" | cut -c1-25; }

# Progress indicator for long-running operations
progress_bar() {
    local current=$1
    local total=$2
    local width=30
    local percentage=$((current * 100 / total))
    local completed=$((current * width / total))
    
    printf "\r["
    for ((i=0; i<completed; i++)); do printf "â–ˆ"; done
    for ((i=completed; i<width; i++)); do printf "â–‘"; done
    printf "] %d%%" $percentage
}

# Environment variable retrieval utility
get_env_value() {
    local var_name="$1"
    if [ -f "$ENV_FILE" ]; then
        grep -E "^${var_name}=" "$ENV_FILE" 2>/dev/null | cut -d= -f2- | tr -d '"'
    fi
}

# Interactive configuration prompt with default value handling
prompt_env() {
    local var_name="$1"
    local message="$2"
    local secret="${3:-false}"
    local existing_value=""
    local user_input=""
    
    # Get existing value from .env file
    if [ -f "$ENV_FILE" ]; then
        existing_value=$(grep -E "^${var_name}=" "$ENV_FILE" 2>/dev/null | cut -d= -f2- | tr -d '"' || true)
    fi
    
    # Display the prompt with existing value as default
    if [ -n "$existing_value" ] && [ "$secret" = "false" ]; then
        printf "%s [%s]: " "$message" "$existing_value" >&2
    elif [ -n "$existing_value" ] && [ "$secret" = "true" ]; then
        printf "%s [***hidden***]: " "$message" >&2
    else
        printf "%s: " "$message" >&2
    fi
    
    if [ "$secret" = "true" ]; then
        read -s user_input
        echo >&2
    else
        read user_input
    fi
    
    # Use existing value if user pressed enter
    if [ -z "$user_input" ] && [ -n "$existing_value" ]; then
        user_input="$existing_value"
    fi
    
    echo "$user_input"
}

# Interactive prompt with customizable default value
prompt_env_with_default() {
    local var_name="$1"
    local message="$2"
    local default_value="$3"
    local secret="${4:-false}"
    local user_input=""
    
    # Display the prompt with default value
    if [ "$secret" = "false" ]; then
        printf "%s [%s]: " "$message" "$default_value" >&2
    else
        printf "%s [***hidden***]: " "$message" >&2
    fi
    
    if [ "$secret" = "true" ]; then
        read -s user_input
        echo >&2
    else
        read user_input
    fi
    
    # Use default value if user pressed enter
    if [ -z "$user_input" ]; then
        user_input="$default_value"
    fi
    
    echo "$user_input"
}

# GitHub Authentication and Registry Access Verification
github_auth() {
    info "GitHub authentication required"
    echo "A GitHub Personal Access Token with 'read:packages' permission is required"
    echo "Generate token at: https://github.com/settings/tokens"
    echo
    
    echo -n "GitHub Username: "
    read github_username
    echo -n "GitHub Personal Access Token: "
    read -s github_token
    echo
    
    if [ -z "$github_username" ] || [ -z "$github_token" ]; then
        error "Both username and personal access token are required"
    fi
    
    echo
    info "Validating GitHub credentials and permissions..."
    
    # Test GitHub API
    if curl -s -H "Authorization: token $github_token" https://api.github.com/user | grep -q "login"; then
        github_user=$(curl -s -H "Authorization: token $github_token" https://api.github.com/user | grep '"login"' | cut -d'"' -f4)
        log "GitHub API access ($github_user)"
    else
        error "GitHub API authentication failed. Please verify your token has the correct permissions"
    fi
    
    # Test package access
    if curl -s -H "Authorization: token $github_token" "https://api.github.com/user/packages?package_type=container" >/dev/null; then
        log "Package registry access"
    else
        warn "Package access limited"
    fi
    
    # Clean Docker auth
    docker logout >/dev/null 2>&1 || true
    
    # Test Docker login
    if echo "$github_token" | docker login ghcr.io -u "$github_username" --password-stdin >/dev/null 2>&1; then
        log "Docker registry login"
    else
        error "GitHub Container Registry authentication failed. Please verify your credentials"
    fi
    
    # Test image pull
    if docker pull --platform linux/amd64 ghcr.io/tofupilot/tofupilot:latest >/dev/null 2>&1; then
        log "TofuPilot image access"
    else
        error "Unable to access TofuPilot container image. Please verify your repository access permissions"
    fi
    
    log "Authentication complete"
}

# System Prerequisites and Dependency Validation
check_requirements() {
    info "Performing system requirements validation"
    
    # Root check
    if [ "$EUID" -eq 0 ] && [ "$ALLOW_ROOT" = "false" ]; then
        error "Execution as root user is not recommended. Use --allow-root flag if administrative privileges are required"
    fi
    
    if [ "$EUID" -eq 0 ] && [ "$ALLOW_ROOT" = "true" ]; then
        warn "Administrative execution detected. This may result in file ownership conflicts"
    fi
    
    # OS check
    if ! command_exists apt; then
        error "This deployment requires Ubuntu or Debian Linux with APT package manager"
    fi
    log "Operating system"
    
    # Docker check
    if ! command_exists docker; then
        info "Installing Docker container runtime..."
        curl -fsSL https://get.docker.com | sh >/dev/null 2>&1
        sudo usermod -aG docker "$USER"
        log "Docker installed"
    else
        log "Docker found"
    fi
    
    # Docker permissions
    if ! docker ps >/dev/null 2>&1; then
        info "Configuring Docker runtime permissions..."
        if ! groups "$USER" | grep -q docker; then
            sudo usermod -aG docker "$USER"
        fi
        sudo chmod 666 /var/run/docker.sock 2>/dev/null || true
        
        if ! docker ps >/dev/null 2>&1; then
            error "Docker permission configuration failed. Please log out and log back in to apply group changes"
        fi
    fi
    log "Docker permissions"
    
    # Docker Compose
    if ! command_exists docker-compose && ! docker compose version >/dev/null 2>&1; then
        info "Installing Docker Compose orchestration tool..."
        sudo apt update >/dev/null 2>&1
        sudo apt install -y docker-compose-plugin >/dev/null 2>&1
        log "Docker Compose installed"
    else
        log "Docker Compose found"
    fi
    
    # Port check
    if command_exists netstat && sudo netstat -tlnp 2>/dev/null | grep -E ':80|:443' >/dev/null 2>&1; then
        warn "Ports 80/443 in use"
    elif command_exists ss && sudo ss -tlnp 2>/dev/null | grep -E ':80|:443' >/dev/null 2>&1; then
        warn "Ports 80/443 in use"
    else
        log "Ports available"
    fi
    
    # Architecture
    ARCH=$(uname -m)
    if [ "$ARCH" = "arm64" ] || [ "$ARCH" = "aarch64" ]; then
        warn "ARM64 detected - using emulation (may be slower)"
    else
        log "Architecture (AMD64)"
    fi
}

# Generate Docker Compose configuration for containerized deployment
create_compose_file() {
  log "Creating Docker Compose configuration..."
  
  # Remove existing compose file if it exists
  if [ -f "$COMPOSE_FILE" ]; then
    rm -f "$COMPOSE_FILE"
    info "Removed existing docker-compose.yml file"
  fi

  cat > "$COMPOSE_FILE" <<'EOF'

services:
  # Reverse proxy with automatic SSL
  tofupilot-proxy:
    image: traefik:v3.0
    container_name: tofupilot-proxy
    restart: unless-stopped
    command:
      - "--api.dashboard=false"
      - "--providers.docker=true"
      - "--providers.docker.exposedbydefault=false"
      - "--entrypoints.web.address=:80"
      - "--entrypoints.websecure.address=:443"
      - "--certificatesresolvers.letsencrypt.acme.tlschallenge=true"
      - "--certificatesresolvers.letsencrypt.acme.email=${ACME_EMAIL}"
      - "--certificatesresolvers.letsencrypt.acme.storage=/data/acme.json"
      - "--entrypoints.web.http.redirections.entrypoint.to=websecure"
      - "--entrypoints.web.http.redirections.entrypoint.scheme=https"
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock:ro
      - tofupilot-proxy-acme:/data
    environment:
      - ACME_EMAIL=${ACME_EMAIL}

  # TofuPilot Application
  tofupilot-app:
    image: ghcr.io/tofupilot/tofupilot:latest
    container_name: tofupilot-app
    restart: unless-stopped
    depends_on:
      - tofupilot-database
      - tofupilot-storage
    environment:
      # Domain Configuration
      - NEXT_PUBLIC_DOMAIN_NAME=${DOMAIN_NAME}
      
      # Authentication Configuration
      - AUTH_SECRET=${AUTH_SECRET}
      - AUTH_URL=https://${DOMAIN_NAME}
      - AUTH_GOOGLE_ID=${AUTH_GOOGLE_ID:-}
      - AUTH_GOOGLE_SECRET=${AUTH_GOOGLE_SECRET:-}
      - AUTH_MICROSOFT_ENTRA_ID_ID=${AUTH_MICROSOFT_ENTRA_ID_ID:-}
      - AUTH_MICROSOFT_ENTRA_ID_SECRET=${AUTH_MICROSOFT_ENTRA_ID_SECRET:-}
      - AUTH_MICROSOFT_ENTRA_ID_ISSUER=${AUTH_MICROSOFT_ENTRA_ID_ISSUER:-}
      
      # Database Configuration
      - GEL_USER=${GEL_USER}
      - GEL_PASSWORD=${GEL_PASSWORD}
      - GEL_DATABASE=${GEL_DATABASE}
      - GEL_HOST=${GEL_HOST}
      - GEL_PORT=${GEL_PORT}
      - GEL_CLIENT_TLS_SECURITY=${GEL_CLIENT_TLS_SECURITY}
      
      # Storage Configuration
      - S3_ACCESS_KEY_ID=${S3_ACCESS_KEY_ID}
      - S3_SECRET_ACCESS_KEY=${S3_SECRET_ACCESS_KEY}
      - S3_ENDPOINT_URL_EXTERNAL=https://${STORAGE_DOMAIN_NAME}
      - S3_ENDPOINT_URL_INTERNAL=http://tofupilot-storage:9000
      - S3_BUCKET_NAME=${S3_BUCKET_NAME}
      - S3_REGION=${S3_REGION}
      
      # Email Configuration
      - EMAIL_SMTP_HOST=${EMAIL_SMTP_HOST:-}
      - EMAIL_SMTP_PORT=${EMAIL_SMTP_PORT:-587}
      - EMAIL_SMTP_USER=${EMAIL_SMTP_USER:-}
      - EMAIL_SMTP_PASSWORD=${EMAIL_SMTP_PASSWORD:-}
      - EMAIL_FROM_AUTH=${EMAIL_FROM_AUTH:-}
    volumes:
      - tofupilot-app-cache:/app/.next/cache
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.tofupilot-app.rule=Host(`${DOMAIN_NAME}`)"
      - "traefik.http.routers.tofupilot-app.entrypoints=websecure"
      - "traefik.http.routers.tofupilot-app.tls.certresolver=letsencrypt"
      - "traefik.http.services.tofupilot-app.loadbalancer.server.port=3000"

  # Database
  tofupilot-database:
    image: geldata/gel:latest
    container_name: tofupilot-database
    restart: unless-stopped
    environment:
      - GEL_USER=${GEL_USER}
      - GEL_PASSWORD=${GEL_PASSWORD}
      - GEL_DATABASE=${GEL_DATABASE}
      - GEL_SERVER_TLS_CERT_MODE=generate_self_signed
      - GEL_SERVER_SECURITY=insecure_dev_mode
    volumes:
      - tofupilot-database-data:/var/lib/gel/data
    ports:
      - "127.0.0.1:5656:5656"

  # Object Storage (MinIO)
  tofupilot-storage:
    image: minio/minio:latest
    container_name: tofupilot-storage
    restart: unless-stopped
    command: server /data --console-address ":9001"
    environment:
      - MINIO_ROOT_USER=${S3_ACCESS_KEY_ID}
      - MINIO_ROOT_PASSWORD=${S3_SECRET_ACCESS_KEY}
    volumes:
      - tofupilot-storage-data:/data
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.tofupilot-storage.rule=Host(`${STORAGE_DOMAIN_NAME}`)"
      - "traefik.http.routers.tofupilot-storage.entrypoints=websecure"
      - "traefik.http.routers.tofupilot-storage.tls.certresolver=letsencrypt"
      - "traefik.http.services.tofupilot-storage.loadbalancer.server.port=9000"

volumes:
  tofupilot-database-data:
  tofupilot-storage-data:
  tofupilot-proxy-acme:
  tofupilot-app-cache:
EOF

  log "Docker Compose file created"
}

# Generate application environment configuration
create_env_file() {
    info "Creating environment file..."
    
    # Backup existing .env
    if [ -f "$ENV_FILE" ]; then
        cp "$ENV_FILE" "${ENV_FILE}.backup.$(date +%s)"
    fi
    
    cat > "$ENV_FILE" <<EOF
# Domain Configuration
DOMAIN_NAME=${DOMAIN_NAME}
STORAGE_DOMAIN_NAME=${STORAGE_DOMAIN_NAME}
ACME_EMAIL=${ACME_EMAIL}

# Authentication Configuration
AUTH_SECRET=${AUTH_SECRET}
AUTH_GOOGLE_ID=${AUTH_GOOGLE_ID:-}
AUTH_GOOGLE_SECRET=${AUTH_GOOGLE_SECRET:-}
AUTH_MICROSOFT_ENTRA_ID_ID=${AUTH_MICROSOFT_ENTRA_ID_ID:-}
AUTH_MICROSOFT_ENTRA_ID_SECRET=${AUTH_MICROSOFT_ENTRA_ID_SECRET:-}
AUTH_MICROSOFT_ENTRA_ID_ISSUER=${AUTH_MICROSOFT_ENTRA_ID_ISSUER:-}

# Database Configuration
GEL_USER=${GEL_USER}
GEL_PASSWORD=${GEL_PASSWORD}
GEL_DATABASE=${GEL_DATABASE}
GEL_HOST=${GEL_HOST}
GEL_PORT=${GEL_PORT}
GEL_CLIENT_TLS_SECURITY=${GEL_CLIENT_TLS_SECURITY}

# Storage Configuration
S3_ACCESS_KEY_ID=${S3_ACCESS_KEY_ID}
S3_SECRET_ACCESS_KEY=${S3_SECRET_ACCESS_KEY}
S3_BUCKET_NAME=${S3_BUCKET_NAME}
S3_REGION=${S3_REGION}

# Email Configuration
EMAIL_SMTP_HOST=${EMAIL_SMTP_HOST:-}
EMAIL_SMTP_PORT=${EMAIL_SMTP_PORT:-587}
EMAIL_SMTP_USER=${EMAIL_SMTP_USER:-}
EMAIL_SMTP_PASSWORD=${EMAIL_SMTP_PASSWORD:-}
EMAIL_FROM_AUTH=${EMAIL_FROM_AUTH:-}
EOF
    log "Environment file created"
}

# Interactive configuration collection and validation
collect_config() {
    
    # Domain Configuration
    echo "Domain Configuration:"
    DOMAIN_NAME=$(prompt_env "DOMAIN_NAME" "Domain name" false)
    if [ -z "$DOMAIN_NAME" ]; then DOMAIN_NAME="tofupilot.example.com"; fi
    
    # Auto-generate storage domain based on main domain
    local storage_default="storage.${DOMAIN_NAME}"
    local existing_storage=$(get_env_value "STORAGE_DOMAIN_NAME")
    if [ -n "$existing_storage" ]; then
        storage_default="$existing_storage"
    fi
    STORAGE_DOMAIN_NAME=$(prompt_env_with_default "STORAGE_DOMAIN_NAME" "Storage domain" "$storage_default" false)
    
    # Auto-generate SSL email based on main domain  
    local email_default="admin@${DOMAIN_NAME}"
    local existing_email=$(get_env_value "ACME_EMAIL")
    if [ -n "$existing_email" ]; then
        email_default="$existing_email"
    fi
    ACME_EMAIL=$(prompt_env_with_default "ACME_EMAIL" "SSL certificate email" "$email_default" false)
    
    echo
    echo "Security Configuration:"
    info "Generating secure passwords automatically..."
    
    # Auto-generate security variables, only use existing if they exist
    AUTH_SECRET=$(get_env_value "AUTH_SECRET")
    if [ -z "$AUTH_SECRET" ]; then 
        AUTH_SECRET=$(generate_password)
        log "Generated Auth secret"
    else
        log "Using existing Auth secret"
    fi
    
    GEL_USER="edgedb"
    GEL_DATABASE="main"
    GEL_HOST="database"
    GEL_PORT="5656"
    GEL_CLIENT_TLS_SECURITY="insecure"
    
    GEL_PASSWORD=$(get_env_value "GEL_PASSWORD")
    # Fallback to legacy EDGEDB_PASSWORD for backward compatibility
    if [ -z "$GEL_PASSWORD" ]; then
        GEL_PASSWORD=$(get_env_value "EDGEDB_PASSWORD")
    fi
    if [ -z "$GEL_PASSWORD" ]; then 
        GEL_PASSWORD=$(generate_password)
        log "Generated database password"
    else
        log "Using existing database password"
    fi
    
    S3_ACCESS_KEY_ID="tofupilot"
    S3_BUCKET_NAME="tofupilot"
    S3_REGION="us-east-1"
    
    S3_SECRET_ACCESS_KEY=$(get_env_value "S3_SECRET_ACCESS_KEY")
    # Fallback to legacy MINIO_SECRET_KEY for backward compatibility
    if [ -z "$S3_SECRET_ACCESS_KEY" ]; then
        S3_SECRET_ACCESS_KEY=$(get_env_value "MINIO_SECRET_KEY")
    fi
    if [ -z "$S3_SECRET_ACCESS_KEY" ]; then 
        S3_SECRET_ACCESS_KEY=$(generate_password)
        log "Generated storage secret key"
    else
        log "Using existing storage secret key"
    fi
    
    echo
    echo "Authentication Configuration (required - choose at least one):"
    info "TofuPilot requires at least one authentication method"
    
    # Initialize variables with existing values as defaults
    AUTH_GOOGLE_ID=$(prompt_env "AUTH_GOOGLE_ID" "Google OAuth Client ID (leave empty to skip)" false)
    if [ -n "$AUTH_GOOGLE_ID" ]; then
        AUTH_GOOGLE_SECRET=$(prompt_env "AUTH_GOOGLE_SECRET" "Google OAuth Client Secret" true)
    else
        AUTH_GOOGLE_SECRET=""
    fi
    
    AUTH_MICROSOFT_ENTRA_ID_ID=$(prompt_env "AUTH_MICROSOFT_ENTRA_ID_ID" "Microsoft Entra ID Client ID (leave empty to skip)" false)
    if [ -n "$AUTH_MICROSOFT_ENTRA_ID_ID" ]; then
        AUTH_MICROSOFT_ENTRA_ID_SECRET=$(prompt_env "AUTH_MICROSOFT_ENTRA_ID_SECRET" "Microsoft Entra ID Client Secret" true)
        AUTH_MICROSOFT_ENTRA_ID_ISSUER=$(prompt_env "AUTH_MICROSOFT_ENTRA_ID_ISSUER" "Microsoft Entra ID Issuer URL" false)
    else
        AUTH_MICROSOFT_ENTRA_ID_SECRET=""
        AUTH_MICROSOFT_ENTRA_ID_ISSUER=""
    fi
    
    echo
    echo "Email Configuration:"
    
    # Check if SMTP is required (no OAuth methods configured)
    local smtp_required=false
    if [ -z "$AUTH_GOOGLE_ID" ] && [ -z "$AUTH_MICROSOFT_ENTRA_ID_ID" ]; then
        smtp_required=true
        info "SMTP email is REQUIRED since no OAuth methods are configured"
    else
        info "SMTP email is optional (OAuth is configured)"
    fi
    
    # Smart default for email from address
    local email_default="tofupilot@${DOMAIN_NAME}"
    local existing_email_from=$(get_env_value "EMAIL_FROM_AUTH")
    # Fallback to legacy EMAIL_FROM for backward compatibility
    if [ -z "$existing_email_from" ]; then
        existing_email_from=$(get_env_value "EMAIL_FROM")
    fi
    if [ -n "$existing_email_from" ]; then
        email_default="$existing_email_from"
    fi
    
    if [ "$smtp_required" = "true" ]; then
        EMAIL_SMTP_HOST=$(prompt_env "EMAIL_SMTP_HOST" "SMTP server hostname" false)
        # Fallback to legacy SMTP_HOST for backward compatibility
        if [ -z "$EMAIL_SMTP_HOST" ]; then
            EMAIL_SMTP_HOST=$(get_env_value "SMTP_HOST")
        fi
        if [ -z "$EMAIL_SMTP_HOST" ]; then
            error "SMTP server hostname is required when no OAuth methods are configured"
        fi
        
        EMAIL_SMTP_PORT=$(prompt_env_with_default "EMAIL_SMTP_PORT" "SMTP port" "587" false)
        # Fallback to legacy SMTP_PORT for backward compatibility
        if [ -z "$EMAIL_SMTP_PORT" ]; then
            EMAIL_SMTP_PORT=$(get_env_value "SMTP_PORT")
        fi
        if [ -z "$EMAIL_SMTP_PORT" ]; then
            EMAIL_SMTP_PORT="587"
        fi
        
        EMAIL_SMTP_USER=$(prompt_env "EMAIL_SMTP_USER" "SMTP username" false)
        # Fallback to legacy SMTP_USER for backward compatibility
        if [ -z "$EMAIL_SMTP_USER" ]; then
            EMAIL_SMTP_USER=$(get_env_value "SMTP_USER")
        fi
        
        EMAIL_SMTP_PASSWORD=$(prompt_env "EMAIL_SMTP_PASSWORD" "SMTP password" true)
        # Fallback to legacy SMTP_PASSWORD for backward compatibility
        if [ -z "$EMAIL_SMTP_PASSWORD" ]; then
            EMAIL_SMTP_PASSWORD=$(get_env_value "SMTP_PASSWORD")
        fi
        EMAIL_FROM_AUTH=$(prompt_env_with_default "EMAIL_FROM_AUTH" "From email address" "$email_default" false)
    else
        EMAIL_SMTP_HOST=$(prompt_env "EMAIL_SMTP_HOST" "SMTP server hostname (leave empty to skip)" false)
        # Fallback to legacy SMTP_HOST for backward compatibility
        if [ -z "$EMAIL_SMTP_HOST" ]; then
            EMAIL_SMTP_HOST=$(get_env_value "SMTP_HOST")
        fi
        if [ -n "$EMAIL_SMTP_HOST" ]; then
            EMAIL_SMTP_PORT=$(prompt_env_with_default "EMAIL_SMTP_PORT" "SMTP port" "587" false)
            # Fallback to legacy SMTP_PORT for backward compatibility
            if [ -z "$EMAIL_SMTP_PORT" ]; then
                EMAIL_SMTP_PORT=$(get_env_value "SMTP_PORT")
            fi
            if [ -z "$EMAIL_SMTP_PORT" ]; then
                EMAIL_SMTP_PORT="587"
            fi
            
            EMAIL_SMTP_USER=$(prompt_env "EMAIL_SMTP_USER" "SMTP username" false)
            # Fallback to legacy SMTP_USER for backward compatibility
            if [ -z "$EMAIL_SMTP_USER" ]; then
                EMAIL_SMTP_USER=$(get_env_value "SMTP_USER")
            fi
            
            EMAIL_SMTP_PASSWORD=$(prompt_env "EMAIL_SMTP_PASSWORD" "SMTP password" true)
            # Fallback to legacy SMTP_PASSWORD for backward compatibility
            if [ -z "$EMAIL_SMTP_PASSWORD" ]; then
                EMAIL_SMTP_PASSWORD=$(get_env_value "SMTP_PASSWORD")
            fi
            EMAIL_FROM_AUTH=$(prompt_env_with_default "EMAIL_FROM_AUTH" "From email address" "$email_default" false)
        else
            EMAIL_SMTP_PORT="587"
            EMAIL_SMTP_USER=""
            EMAIL_SMTP_PASSWORD=""
            EMAIL_FROM_AUTH=""
        fi
    fi
    
    # Final validation
    if [ -z "$AUTH_GOOGLE_ID" ] && [ -z "$AUTH_MICROSOFT_ENTRA_ID_ID" ] && [ -z "$EMAIL_SMTP_HOST" ]; then
        error "At least one authentication method must be configured (Google OAuth, Microsoft Entra ID, or SMTP email)"
    fi
    
    echo
    log "Configuration complete"
}

# Deploy the application
deploy() {
    log "Starting deployment process..."
    
    # Configuration variables are already loaded in main script
    # Create configuration files
    info "Generating deployment configuration files..."
    create_compose_file
    create_env_file
    
    info "Downloading container images from registry..."
    
    if docker compose -f "$COMPOSE_FILE" --env-file "$ENV_FILE" pull; then
        log "Images downloaded"
    else
        error "Container image download failed. Please verify network connectivity and registry access"
    fi
    
    info "Initializing containerized services..."
    docker compose -f "$COMPOSE_FILE" --env-file "$ENV_FILE" up -d
    
    if ! docker compose -f "$COMPOSE_FILE" ps 2>/dev/null | grep -q "Up"; then
        error "Service initialization failed. Review deployment logs using: docker compose logs"
    fi
    
    log "Services started"
    
    info "Performing service readiness validation..."
    
    # Wait for database
    local db_ready=false
    for i in {1..30}; do
        if docker compose -f "$COMPOSE_FILE" ps database 2>/dev/null | grep -q "Up"; then
            db_ready=true
            break
        fi
        progress_bar $i 30
        sleep 2
    done
    echo
    
    if [ "$db_ready" = "true" ]; then
        log "Database container is running"
    else
        warn "Database startup is taking longer than expected. This is normal for first-time setup."
    fi
    
    # Quick app check
    info "Validating application service status..."
    if docker compose -f "$COMPOSE_FILE" ps app 2>/dev/null | grep -q "Up"; then
        log "Application container is running"
    else
        warn "Application initialization in progress. Monitor with: docker compose logs app"
    fi
    
    # Check if services are running
    info "Verifying service status..."
    
    if docker compose -f "$COMPOSE_FILE" ps 2>/dev/null | grep -q "Up"; then
        log "All services running"
        
        # Check for exec format errors in app container
        if docker compose -f "$COMPOSE_FILE" logs app 2>/dev/null | grep -q "exec format error"; then
            error "TofuPilot app failed with 'exec format error' - architecture compatibility issue.

This happens on ARM64 systems (Apple Silicon Macs) when Docker can't emulate AMD64 images.

Solutions:
1. **Docker Desktop (Mac)**: Enable 'Use Rosetta for x86/amd64 emulation on Apple Silicon'
   - Docker Desktop â†’ Settings â†’ General â†’ Use Rosetta...
   
2. **Install QEMU emulators**: 
   docker run --rm --privileged tonistiigi/binfmt --install all
   
3. **Alternative**: Contact TofuPilot for ARM64-native images

Then restart the deployment:
   docker compose down
   bash <(curl -s https://raw.githubusercontent.com/tofupilot/self-hosting/main/deploy.sh)"
        fi
        
        info "Checking SSL certificates..."
        
        # Instant check for HTTPS
        if curl -f -s -I "https://${DOMAIN_NAME}" >/dev/null 2>&1; then
            log "HTTPS accessible at https://${DOMAIN_NAME}"
        else
            warn "HTTPS not ready yet. SSL certificates may take a few minutes to generate."
            info "Check later with: curl -I https://${DOMAIN_NAME}"
            if curl -f -s -I "http://${DOMAIN_NAME}" >/dev/null 2>&1; then
                info "HTTP is working: http://${DOMAIN_NAME}"
            fi
        fi
    else
        error "Some services failed to start. Check logs with: docker compose logs"
    fi
}

# Show deployment information
show_info() {
    echo
    echo "=================================="
    log "ðŸŽ‰ TofuPilot deployment completed successfully!"
    echo "=================================="
    echo
    info "Your TofuPilot instance is accessible at:"
    echo "  â€¢ Main app: https://${DOMAIN_NAME}"
    echo "  â€¢ Storage:  https://${STORAGE_DOMAIN_NAME}"
    echo
    warn "Complete identity provider configuration:"
    if [ -n "$AUTH_GOOGLE_ID" ]; then
        echo "  â€¢ Google OAuth: Configure redirect URI:"
        echo "    https://${DOMAIN_NAME}/api/auth/callback/google"
    fi
    if [ -n "$AUTH_MICROSOFT_ENTRA_ID_ID" ]; then
        echo "  â€¢ Microsoft Entra ID: Configure redirect URI:"
        echo "    https://${DOMAIN_NAME}/api/auth/callback/microsoft-entra-id"
    fi
    if [ -n "$EMAIL_SMTP_HOST" ]; then
        echo "  â€¢ SMTP Authentication: Configured using ${EMAIL_SMTP_HOST}"
    fi
    echo
    info "Next steps:"
    echo "  1. Complete authentication provider setup above"
    echo "  2. Access your TofuPilot instance at https://${DOMAIN_NAME}"
    echo
    info "Administrative commands:"
    echo "  â€¢ View logs:    docker compose logs -f"
    echo "  â€¢ Stop:         docker compose down"
    echo "  â€¢ Restart:      docker compose restart"
    echo "  â€¢ Status:       curl -sSL <installer-url> | bash -s -- --status"
    echo
}



# Show service status
show_status() {
    if [ ! -f "$COMPOSE_FILE" ]; then
        error "No deployment found."
    fi
    
    log "Checking TofuPilot service status..."
    echo
    echo "TofuPilot Service Status"
    echo "======================="
    echo
    
    # Show docker-compose status (TofuPilot containers only)
    info "Docker Container Status:"
    docker compose -f "$COMPOSE_FILE" ps 2>/dev/null | grep tofupilot
    
    info "Data Volumes:"
    local volumes=$(docker system df -v 2>/dev/null | grep -E "(root_tofupilot-database-data|root_tofupilot-storage-data|root_tofupilot-proxy-acme|root_tofupilot-app-cache)" | awk '{print $1 " " $3}')
    if [ -n "$volumes" ]; then
        echo "$volumes" | while read name size; do
            echo "  $name: $size"
        done
    fi
    
    echo
    echo "Health Checks:"
    
    # Source environment for domain names
    if [ -f "$ENV_FILE" ]; then
        set -a
        source "$ENV_FILE"
        set +a
    fi
    
    # Check if main app is responding
    info "Testing main application connectivity..."
    if curl -f -s -I "https://${DOMAIN_NAME:-localhost}" >/dev/null 2>&1; then
        echo "âœ“ Main application: healthy (https://${DOMAIN_NAME:-localhost})"
    elif curl -f -s -I "http://${DOMAIN_NAME:-localhost}" >/dev/null 2>&1; then
        echo "~ Main application: accessible (SSL provisioning)"
    else
        echo "âœ— Main application: not responding"
    fi
    
    # Check storage
    info "Testing storage connectivity..."
    if curl -f -s -I "https://${STORAGE_DOMAIN_NAME:-storage.localhost}" >/dev/null 2>&1; then
        echo "âœ“ Storage: healthy (https://${STORAGE_DOMAIN_NAME:-storage.localhost})"
    elif curl -f -s -I "http://${STORAGE_DOMAIN_NAME:-storage.localhost}" >/dev/null 2>&1; then
        echo "~ Storage: accessible (SSL provisioning)"  
    else
        echo "âœ— Storage: not responding"
    fi
    
    echo
    echo "URLs:"
    echo "  Main app: https://${DOMAIN_NAME:-localhost}"
    echo "  Storage:  https://${STORAGE_DOMAIN_NAME:-storage.localhost}"
}

# Show logs
show_logs() {
    local service="$1"
    
    if [ ! -f "$COMPOSE_FILE" ]; then
        error "No deployment found."
    fi
    
    if [ -n "$service" ]; then
        log "Showing logs for service: $service"
        docker compose -f "$COMPOSE_FILE" logs -f --tail=100 "$service"
    else
        log "Showing logs for all services"
        docker compose -f "$COMPOSE_FILE" logs -f --tail=100
    fi
}

# Restart services
restart_services() {
    local service="$1"
    
    if [ ! -f "$COMPOSE_FILE" ]; then
        error "No deployment found."
    fi
    
    if [ -n "$service" ]; then
        log "Restarting service: $service"
        docker compose -f "$COMPOSE_FILE" restart "$service"
    else
        log "Restarting all services"
        docker compose -f "$COMPOSE_FILE" restart
    fi
    
    log "Restart complete"
}

# Stop services
stop_services() {
    if [ ! -f "$COMPOSE_FILE" ]; then
        error "No deployment found."
    fi
    
    log "Stopping all services..."
    docker compose -f "$COMPOSE_FILE" down
    log "All services stopped"
}

# Start services  
start_services() {
    if [ ! -f "$COMPOSE_FILE" ]; then
        error "No deployment found."
    fi
    
    log "Starting all services..."
    docker compose -f "$COMPOSE_FILE" up -d
    log "All services started"
}

# Uninstall TofuPilot completely
uninstall_tofupilot() {
    echo
    echo "=========================================="
    echo -e "${RED}âš ï¸  TofuPilot Complete Uninstall${NC}"
    echo "=========================================="
    echo
    warn "This will completely remove:"
    echo "- All TofuPilot containers"
    echo "- All TofuPilot volumes (database data will be lost)"
    echo "- Configuration files (.env, docker-compose.yml)"
    echo "- Docker images and unused volumes"
    echo
    
    printf "${RED}Are you sure you want to completely uninstall TofuPilot? (y/N): ${NC}"
    read -r confirm
    if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
        echo "Uninstall cancelled."
        exit 0
    fi
    
    echo
    printf "${RED}This action is IRREVERSIBLE. Type 'DELETE' to confirm: ${NC}"
    read -r final_confirm
    if [ "$final_confirm" != "DELETE" ]; then
        echo "Uninstall cancelled."
        exit 0
    fi
    
    echo
    step "1/6: STOPPING SERVICES"
    if [ -f "$COMPOSE_FILE" ]; then
        docker compose -f "$COMPOSE_FILE" down -v 2>/dev/null || docker-compose -f "$COMPOSE_FILE" down -v 2>/dev/null || true
        log "Services stopped"
    else
        warn "No docker-compose.yml found"
    fi
    
    step "2/6: REMOVING CONTAINERS"
    docker ps -a --filter "name=tofupilot" --format "{{.Names}}" | xargs -r docker rm -f 2>/dev/null || true
    log "Containers removed"
    
    step "3/6: REMOVING VOLUMES"
    docker volume ls --filter "name=tofupilot" --format "{{.Name}}" | xargs -r docker volume rm 2>/dev/null || true
    docker volume ls --filter "name=root" --format "{{.Name}}" | grep -E "(tofupilot-database-data|tofupilot-storage-data|tofupilot-proxy-acme|tofupilot-app-cache)" | xargs -r docker volume rm 2>/dev/null || true
    log "Volumes removed"
    
    step "4/6: REMOVING CONFIGURATION"
    rm -f "$ENV_FILE" "$COMPOSE_FILE" "${ENV_FILE}.backup."* 2>/dev/null || true
    log "Configuration files removed"
    
    step "5/6: CLEANING DOCKER SYSTEM"
    docker system prune -f --volumes 2>/dev/null || true
    log "Docker system cleaned"
    
    step "6/6: REMOVING IMAGES"
    docker images --filter "reference=ghcr.io/tofupilot/*" --format "{{.Repository}}:{{.Tag}}" | xargs -r docker rmi 2>/dev/null || true
    log "Images removed"
    
    echo
    log "ðŸŽ‰ TofuPilot completely uninstalled!"
    echo
    echo "To reinstall TofuPilot, run:"
    echo "  bash <(curl -s https://raw.githubusercontent.com/tofupilot/self-hosting/main/deploy.sh)"
    echo
}

# Show usage
usage() {
    echo "TofuPilot Self-Hosting Deployment Script"
    echo "=========================="
    echo
    echo "Usage: curl -sSL <installer-url> | bash -s -- [OPTIONS]"
    echo
    echo "Main Commands:"
    echo "  (no options)            Fresh TofuPilot installation"
    echo "  --allow-root            Allow running as root user (use with caution)"
    echo
    echo "Service Management:"
    echo "  --status                Show service status and health"
    echo "  --logs [service]        Show logs (all services or specific)"
    echo "  --restart [service]     Restart services (all or specific)"
    echo "  --start                 Start all services"
    echo "  --stop                  Stop all services"
    echo
    echo "  --uninstall             Completely remove TofuPilot (with confirmation)"
    echo "  --help                  Show this help message"
    echo
    echo "Examples:"
    echo "  curl -sSL <url> | bash                    # Fresh installation"
    echo "  curl -sSL <url> | bash -s -- --allow-root # Fresh installation as root"
    echo ""
    echo "  curl -sSL <url> | bash -s -- --status    # Check deployment status"
    echo "  curl -sSL <url> | bash -s -- --logs app  # Show application logs"
    echo "  curl -sSL <url> | bash -s -- --uninstall # Completely remove TofuPilot"
    echo
    echo "For more information, visit: https://docs.tofupilot.com"
}

#----------------------------#
#         Main Script        #
#----------------------------#

# Initialize variables
ALLOW_ROOT="false"

# Show banner for all operations
show_banner

# Parse command line arguments
case "${1:-}" in
    --allow-root)
        ALLOW_ROOT="true"
        shift
        ;;
    --status)
        show_status
        exit 0
        ;;
    --logs)
        show_logs "$2"
        exit 0
        ;;
    --restart)
        restart_services "$2"
        exit 0
        ;;
    --stop)
        stop_services
        exit 0
        ;;
    --start)
        start_services
        exit 0
        ;;
    --uninstall)
        uninstall_tofupilot
        exit 0
        ;;
    --help)
        usage
        exit 0
        ;;
    "")
        # Continue with installation
        ;;
    *)
        error "Unknown option: $1. Use --help for usage information."
        ;;
esac

# Main installation flow

step "1/6: PRE-FLIGHT CHECKS"
check_requirements

echo
step "2/6: GITHUB AUTHENTICATION"
github_auth

echo
step "3/6: CONFIGURATION"
collect_config

echo
step "4/6: DEPLOYMENT"
deploy

step "5/6: VERIFICATION"
info "Verifying deployment status..."
sleep 2

step "6/6: COMPLETE"
show_info

